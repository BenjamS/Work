# library(lamW)
library(rootSolve)
library(tidyverse)
#=============================================================
#=============================================================
#=============================================================
# Define functions
#=============================================================
#=============================================================
#=============================================================
# Tech adoption
#=============================================================
get_adopt_range <- function(delta_tech, delta_P, quietly = T){
  # delta_tech <- .9
  # delta_P <- 0.95 # Must be > delta_tech?
  ratio_deltas <- delta_tech / delta_P
  ly_switch <- -log(delta_P) / (ratio_deltas - 1)
  #if(delta_P > 1){
  if(ratio_deltas < 1){
    tech_is_pro_poor <- T
  }else{
    tech_is_pro_poor <- F
  }
  if(ly_switch > -1 & ly_switch < 0){
    if(tech_is_pro_poor){
      adopt_bounds <- c(-1, ly_switch)
    }else{
      adopt_bounds <- c(ly_switch, 0)
    }
  }else{
    if(ly_switch < -1){
      if(tech_is_pro_poor){
        adopt_bounds <- NA  
      }else{
        adopt_bounds <- c(-1, 0)
      }
    }
    if(ly_switch > 0){
      if(tech_is_pro_poor){
        adopt_bounds <- c(-1, 0)
      }else{
        adopt_bounds <- NA
      }
    }
  }
  
  if(!quietly){
    print("Adoption log yield (normalized) bounds:")
    print(adopt_bounds)
    print("ly_switch:")
    print(ly_switch)
    if(tech_is_pro_poor){
      print("Tech is pro-poor")
    }else{
      print("Tech is not pro-poor")
    }
  }
  
  out_list <- list(adopt_bounds, tech_is_pro_poor)
  return(out_list)
}    


graph_diffNR1NR0 <- function(delta_tech, delta_P, yCeil){
    ly0_vec <- seq(-1, 0, length.out = 25)
    
    ratio_deltas <- delta_tech / delta_P
    ly_switch <- -log(delta_P) / (ratio_deltas - 1)
    
    R_0 <- yCeil * exp(ly0_vec)
    R_1 <- yCeil * exp(ly0_vec * delta_tech / delta_P) * delta_P
    diff_NR1NR0 <- R_1 - R_0
    df_plot <- data.frame(ly0_vec, diff_NR1NR0)
    gg <- ggplot(df_plot, aes(x = ly0_vec, y = diff_NR1NR0))
    gg <- gg + geom_line()
    gg <- gg + geom_hline(yintercept = 0, color = "violet", size = 1)
#    gg <- gg + geom_vline(xintercept = ly_switch, color = "violet", size = 1)
    gg <- gg + labs(x = "Log yield index", y = expression("Diff. in net rev. ("*ha.^-1 ~Price^-1*")"))
    gg
    
}


# delta_tech <- 1.1
# delta_P <- 1.03
# out <- get_adopt_range(delta_tech, delta_P, quietly = T)
# adopt_bounds <- out[[1]]
# tech_is_pro_poor <- out[[2]]
# adopt_bounds
# tech_is_pro_poor
# graph_diffNR1NR0(delta_tech, delta_P, yCeil)

get_lq_bounds <- function(adopt_bounds, tech_is_pro_poor, which_tech){
  if(which_tech == "baseline"){
    zero_adoption <- F
    full_adoption <- F
    if(is.na(adopt_bounds)){
      lq_bounds <- c(-1, 0)
      zero_adoption <- T
    }
    if(adopt_bounds[1] == -1 & adopt_bounds[2] == 0){
        lq_bounds <- NA
        full_adoption <- T
    }
      
    if(zero_adoption == F & full_adoption == F){
      if(tech_is_pro_poor){
        lq_lower <- adopt_bounds[2]
        lq_upper <- 0
      }else{
        lq_lower <- -1
        lq_upper <- adopt_bounds[1]
      }
      lq_bounds <- c(lq_lower, lq_upper)
      
    }
    
  }

  if(which_tech == "new"){
    lq_bounds <- adopt_bounds
  }
  
  return(lq_bounds)
}

#=============================================================
# Supply function
#=============================================================
QS_at_P <- function(P, QS_env){
  mu_alpha <- QS_env[["mu_alpha"]]
  sig_alpha <- QS_env[["sig_alpha"]]
  yCeil <- QS_env[["yCeil"]]
  m_A <- QS_env[["m_A"]]
  s_A <- QS_env[["s_A"]]
  N <- QS_env[["N"]]
  lq_bounds <- QS_env[["lq_bounds"]]

  m_y <- log(yCeil) + mu_alpha / P
  s_y <- sig_alpha / P
  mu_y <- exp(m_y + s_y^2 / 2)
  
  mu_A <- exp(m_A + s_A^2 / 2)
  
  mu_q <- mu_y * mu_A
  
  s_q <- s_A + s_y

  supply_is_zero <- F
  if(is.null(lq_bounds)){
    lq_lower <- -1
    lq_upper <- 0
  }else{
    if(is.na(lq_bounds)){
      supply_is_zero <- T
    }else{
      lq_lower <- lq_bounds[1]
      lq_upper <- lq_bounds[2]
    }
    
  }
  
  if(supply_is_zero){
    mkt_particip <- 0
    QS <- 0
  }else{
    u_upper <- (lq_upper - mu_alpha / P) / s_q
    u_lower <- (lq_lower - mu_alpha / P) / s_q
    
    theta_upper <- u_upper - s_q
    theta_lower <- u_lower - s_q
    
    N_upper <- pnorm(theta_upper)
    N_lower <- pnorm(theta_lower)
    mkt_particip <- N_upper - N_lower
    QS <- N * mu_q * mkt_particip
  }
  out_vec <- c(P, QS, mkt_particip)
  
  return(out_vec)
}
#-------------------------------------------------------------
QS_curve <- function(P_vec, QS_env){
  list_out <- purrr::map(P_vec, QS_at_P, QS_env)
  return(list_out)
}
#=============================================================
# Demand curve
#=============================================================
QD_at_P <- function(P, QD_env){
  P_output <- QD_env[["P_output"]]
  a_e <- QD_env[["a_e"]] 
  gamma_D <- QD_env[["gamma_D"]]
  N_D <- QD_env[["N_D"]]
  QD <- N_D * P_output / (P * gamma_D) * a_e
  out_vec <- c(P, QD)
  return(out_vec)
}
#-------------------------------------------------------------
QD_curve <- function(P_vec, QD_env){
  list_out <- purrr::map(P_vec, QD_at_P, QD_env)
  return(list_out)
}
#=============================================================
# Equilibrium
#=============================================================
equilib_rootfn <- function(P_vec, QS_env, QD_env){
  
  QS <- QS_curve(P_vec, QS_env)
  QS <- as.data.frame(do.call(rbind, QS))
  QS <- QS[, 2]
  
  QD <- QD_curve(P_vec, QD_env)
  QD <- as.data.frame(do.call(rbind, QD))
  QD <- QD[, 2]
  
  slack <- QS - QD
  return(slack)
} 

QSQD_Equilib <- function(interval_P, QS_env, QD_env){
  
  P_E <- uniroot.all(equilib_rootfn,
                     interval_P,
                     lower = min(interval_P),
                     upper = max(interval_P),
                     QS_env = QS_env,
                     QD_env = QD_env)
  
  QS_vec <- QS_at_P(P_E, QS_env)
  
  return(QS_vec)
  
}


#=============================================================
#=============================================================
#=============================================================
# End function definitions
#=============================================================
#=============================================================
#=============================================================
# Define parameters
#-------------------------------------------------------------
# Supply
#-------------------------------------------------------------
mu_alpha <- -1000
cv_alpha <- 0.6
sig_alpha <- abs(mu_alpha * cv_alpha)
yCeil <- 44
m_A <- log(2)
cv_A <- 0.8
s_A <- m_A * cv_A
N <- 40
lq_bounds <- NULL
#-------------------------------------------------------------
# Demand
#-------------------------------------------------------------
# QD <- N_D * P_output / (P * gamma_D) * a_e
QD_obs <- 900 # observed demand
P_E_obs <- 2300 # observed equilibrium price
P_output <- 23500
gamma_D <- 1.05
N_D <- 3
a_e <- QD_obs / (N_D * P_output) * P_E_obs * gamma_D
#=============================================================
P_vec <- seq(200, 5000, length.out = 50)
#=============================================================
# P <- 1800
# QS_at_P(P, mu_alpha, sig_alpha, yCeil, m_A, s_A, N)
QS_env <- list()
QS_env[["mu_alpha"]] <- mu_alpha
QS_env[["sig_alpha"]] <- sig_alpha
QS_env[["yCeil"]] <- yCeil
QS_env[["m_A"]] <- m_A
QS_env[["s_A"]] <- s_A
QS_env[["N"]] <- N
QS_env[["lq_bounds"]] <- NULL
list_QS_curve <- QS_curve(P_vec, QS_env)
df_QS <- as.data.frame(do.call(rbind, list_QS_curve))
colnames(df_QS) <- c("Price (Baht / MT)", "Supply", "Market Participation")

QD_env <- list()
QD_env[["P_output"]] <- P_output
QD_env[["a_e"]] <- a_e
QD_env[["gamma_D"]] <- gamma_D
QD_env[["N_D"]] <- N_D
list_QD_curve <- QD_curve(P_vec, QD_env)
df_QD <- as.data.frame(do.call(rbind, list_QD_curve))
colnames(df_QD) <- c("Price (Baht / MT)", "Demand")
df_plot <- df_QS
# gg <- ggplot(df_plot, aes(x = Price, y = Supply))
# gg <- gg + geom_line()
# gg
# df_plot <- df_QD
# gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = Demand))
# gg <- gg + geom_line()
# gg

df_plot <- merge(df_QS, df_QD)
df_plot$`Market Participation` <- NULL
df_plot <- df_plot %>% gather(Type, `Quantity (MT)`, Demand:Supply)

gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = `Quantity (MT)`, group = Type, color = Type))
gg <- gg + geom_line(lwd = 1)
gg <- gg + coord_cartesian(ylim = c(0, 2000))
gg <- gg + theme(legend.title = element_blank())
gg

interval_P <- c(200, 3000)
equilib_vec <- QSQD_Equilib(interval_P, QS_env, QD_env)
equilib_vec
#=============================================================
#=============================================================
#=============================================================
#=============================================================
#=============================================================
# Technology adoption analysis
#=============================================================
#=============================================================
#=============================================================
# delta_tech <- 1.1
# delta_P <- 1.03
delta_tech <- 1.11
delta_P <- 1.03 # Must be > delta_tech?
graph_diffNR1NR0(delta_tech, delta_P, yCeil)

which_tech <- "baseline"
out_list <- get_adopt_range(delta_tech, delta_P, quietly = F)
adopt_bounds <- out_list[[1]]
tech_is_pro_poor <- out_list[[2]]
lq_bounds <- get_lq_bounds(adopt_bounds, tech_is_pro_poor, which_tech)
QS_env[["lq_bounds"]] <- lq_bounds
list_QS_curve <- QS_curve(P_vec, QS_env)
df_QS <- as.data.frame(do.call(rbind, list_QS_curve))
colnames(df_QS) <- c("Price (Baht / MT)", "Supply", "Market Participation")
df_QS_0 <- df_QS %>% gather(Item, Value, Supply:`Market Participation`)
df_QS_0$Tech <- "Baseline"
QS_env_0 <- QS_env


df_plot <- df_QS_0
gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = Value))
gg <- gg + geom_line()
#gg <- gg + geom_vline(xintercept = P_1 / delta_tech, color = "violet", size = 1)
gg <- gg + facet_wrap(~Item, ncol = 1, scales = "free")
gg

which_tech <- "new"
lq_bounds <- get_lq_bounds(adopt_bounds, tech_is_pro_poor, which_tech)
QS_env[["lq_bounds"]] <- lq_bounds
QS_env[["mu_alpha"]] <- mu_alpha * delta_tech
QS_env[["sig_alpha"]] <- abs(cv_alpha * mu_alpha * delta_tech)
list_QS_curve <- QS_curve(P_vec, QS_env)
df_QS <- as.data.frame(do.call(rbind, list_QS_curve))
colnames(df_QS) <- c("Price (Baht / MT)", "Supply", "Market Participation")
df_QS_1 <- df_QS %>% gather(Item, Value, Supply:`Market Participation`)
df_QS_1$Tech <- "Small Granule\nSupply"
QS_env_1 <- QS_env

df_plot <- df_QS_1
gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = Value))
gg <- gg + geom_line()
gg <- gg + facet_wrap(~Item, ncol = 1, scales = "free")
gg

df_QS_1_0 <- rbind(df_QS_0, df_QS_1)
df_plot <- df_QS_1_0
gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = Value, group = Tech, color = Tech))
gg <- gg + geom_line()
gg <- gg + facet_wrap(~Item, ncol = 1, scales = "free")
gg


eff_enhance <- 1.1
df_QD_0 <- df_QD
colnames(df_QD_0)[2] <- "Quantity (MT)"
df_QD_0$Type <- "Baseline Demand"

QD_env_0 <- QD_env
QD_env_1 <- QD_env
QD_env_1[["a_e"]] <- a_e * eff_enhance
list_QD_curve <- QD_curve(P_vec, QD_env_1)
df_QD_1 <- as.data.frame(do.call(rbind, list_QD_curve))
colnames(df_QD_1) <- c("Price (Baht / MT)", "Quantity (MT)")
df_QD_0$Type <- "Small Granule\nDemand"

df_QD_1_0 <- rbind(df_QD_0, df_QD_1)

df_QS_QD <- subset(df_QS_1_0, Item != "Market Participation")
df_QS_QD$Item <- NULL
colnames(df_QS_QD)[2:3] <- c("Quantity (MT)", "Type")
df_QS_QD$Type <- paste(df_QS_QD$Type, "Supply")
df_QS_QD <- rbind(df_QS_QD, df_QD_1_0)

df_plot <- df_QS_QD
gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = `Quantity (MT)`, group = Type, color = Type))
gg <- gg + geom_line(lwd = 1)
gg <- gg + theme(legend.title = element_blank())
gg <- gg + coord_cartesian(ylim = c(0, 800))
gg


interval_P <- c(500, 5000)
equilib_vec_0 <- QSQD_Equilib(interval_P, QS_env_0, QD_env_0)
equilib_vec_1 <- QSQD_Equilib(interval_P, QS_env_1, QD_env_1)
equilib_vec_0
equilib_vec_1


P_E_0 <- equilib_vec_0[1]
P_E_1 <- equilib_vec_1[1]
QD_0 <- equilib_vec_0[2]
QD_1 <- equilib_vec_1[2]
Mkt_Part_0 <- equilib_vec_0[3]
Mkt_Part_1 <- equilib_vec_1[3]

CD_0 <- QD_0 * P_E_0
CD_1 <- QD_1 * P_E_1
CD_tot <- CD_0 + CD_1
CD_0
CD_1
CD_tot

Q_output_ethanol <- QD_0 * MT_to_kl_0 + QD_1 * MT_to_kl_1
R <- P_output * Q_output_ethanol
NR <- R - CD_tot
#=============================================================
#=============================================================



