# library(lamW)
library(rootSolve)
library(tidyverse)
#=============================================================
#=============================================================
#=============================================================
# Define functions
#=============================================================
#=============================================================
#=============================================================
# Tech adoption
#=============================================================
get_adopt_range <- function(P_0, P_1, delta, yCeil, which_tech, graph_on = F, quietly = T){
  
  new_factor <- delta * P_0 / P_1
  ly_switch <- (log(P_0) - log(P_1)) / (new_factor - 1)
  a_little <- 0.01
  ly_switch_plus_e <- ly_switch + a_little
  
  R_0 <- yCeil * exp(ly_switch_plus_e) * P_0
  R_1 <- yCeil * exp(factor * ly_switch_plus_e) * P_1
  diff_NR1NR0 <- R_1 - R_0
  
  if(ly_switch > -1 & ly_switch < 0){
    if(diff_NR1NR0 < 0){
      if(!quietly){print("Tech is pro-poor")}
      tech_is_pro_poor <- T
    }else{
      if(!quietly){print("Tech is not pro-poor")}
      tech_is_pro_poor <- F
    }
    
  }else{
    if(!quietly){"ly_switch not on interval (-1, 0)"}
    tech_is_pro_poor <- NA
  }
  
  
  if(!is.na(tech_is_pro_poor)){
    if(tech_is_pro_poor){
      ly_adopt_bounds <- c(-1, ly_switch)
      if(which_tech == "baseline"){
        ly_QS_bounds <- c(ly_switch, 0)
      }
      if(which_tech == "new"){
        ly_QS_bounds <- ly_adopt_bounds
      }
      
    }else{
      ly_adopt_bounds <- c(ly_switch, 0)
      if(which_tech == "baseline"){
        ly_QS_bounds <- c(-1, ly_switch)
      }
      if(which_tech == "new"){
        ly_QS_bounds <- ly_adopt_bounds
      }
      
      
    }
    
  }else{
    if(diff_NR1NR0 > 0){
      ly_adopt_range <- c(-1, 0)
      if(which_tech == "baseline"){
        ly_QS_bounds <- NA
      }
      if(which_tech == "new"){
        ly_QS_bounds <- ly_adopt_bounds
      }
      
    }else{
      ly_adopt_range <- NA
      if(which_tech == "baseline"){
        ly_QS_bounds <- c(-1, 0)
      }
      if(which_tech == "new"){
        ly_QS_bounds <- ly_adopt_bounds
      }
      
    }
  }
  
  #--  
  
  if(graph_on){
    ly0_vec <- seq(-1, 0, length.out = 25)
    R_0 <- yCeil * exp(ly0_vec) * P_0
    R_1 <- yCeil * exp(delta * ly0_vec * P_0 / P_1) * P_1
    #plot(r_vec, R_1 - R_0)
    diff_NR1NR0 <- R_1 - R_0
    df_plot <- data.frame(ly0_vec, diff_NR0NR1)
    gg <- ggplot(df_plot, aes(x = ly0_vec, y = diff_NR1NR0))
    gg <- gg + geom_line()
    gg <- gg + geom_hline(yintercept = 0, color = "violet", size = 1)
    gg <- gg + labs(x = "Log yield index", y = "Diff. in net rev. / ha. (new - baseline)")
    gg
    
  }
  #--
  
  out_list <- list(ly_QS_bounds, ly_adopt_bounds, ly_switch, tech_is_proo_poor)
  return(out_list)
  
}


#=============================================================
# Supply function
#=============================================================
QS_at_P <- function(P, QS_env){
  mu_alpha <- QS_env[["mu_alpha"]]
  sig_alpha <- QS_env[["sig_alpha"]]
  yCeil <- QS_env[["yCeil"]]
  m_A <- QS_env[["m_A"]]
  s_A <- QS_env[["s_A"]]
  N <- QS_env[["N"]]
  adopt_list <- QS_env[["adopt_list"]]

  m_y <- log(yCeil) + mu_alpha / P
  s_y <- sig_alpha / P
  mu_y <- exp(m_y + s_y^2 / 2)
  
  mu_A <- exp(m_A + s_A^2 / 2)
  
  mu_q <- mu_y * mu_A
  
  s_q <- s_A + s_y
  
  supply_is_zero <- F
  if(is.null(adopt_list)){
    lq_lower <- -1
    lq_upper <- 0
  }else{
    delta <- adopt_list[[1]]
    P_1 <- adopt_list[[2]]
    P_0 <- P
    which_tech <- adopt_list[[3]]
    out_list <- get_adopt_range(P_0, P_1, delta, yCeil, which_tech, graph_on = F, quietly = T)
    lq_bounds <- out_list[[1]]
    if(is.na(lq_bounds)){
      supply_is_zero <- T
    }else{
      lq_lower <- lq_bounds[1]
      lq_upper <- lq_bounds[2]
    }
  }
  

  if(supply_is_zero){
    mkt_particip <- 0
    QS <- 0
  }else{
    u_upper <- (lq_upper - mu_alpha / P) / s_q
    u_lower <- (lq_lower - mu_alpha / P) / s_q
    
    theta_upper <- u_upper - s_q
    theta_lower <- u_lower - s_q
    
    N_upper <- pnorm(theta_upper)
    N_lower <- pnorm(theta_lower)
    mkt_particip <- N_upper - N_lower
    QS <- N * mu_q * mkt_particip
  }
  out_vec <- c(P, QS, mkt_particip)
  
  return(out_vec)
}
#-------------------------------------------------------------
QS_curve <- function(P_vec, QS_env){
  list_out <- purrr::map(P_vec, QS_at_P, QS_env)
  return(list_out)
}
#=============================================================
# Demand curve
#=============================================================
QD_at_P <- function(P, QD_env){
  P_output <- QD_env[["P_output"]]
  a_e <- QD_env[["a_e"]] 
  gamma_D <- QD_env[["gamma_D"]]
  N_D <- QD_env[["N_D"]]
  QD <- N_D * P_output / (P * gamma_D) * a_e
  out_vec <- c(P, QD)
  return(out_vec)
}
#-------------------------------------------------------------
QD_curve <- function(P_vec, QD_env){
  list_out <- purrr::map(P_vec, QD_at_P, QD_env)
  return(list_out)
}
#=============================================================
# Equilibrium
#=============================================================
equilib_rootfn <- function(P_vec, QS_env, QD_env){
  
  QS <- QS_curve(P_vec, QS_env)
  QS <- as.data.frame(do.call(rbind, QS))
  QS <- QS[, 2]
  
  QD <- QD_curve(P_vec, QD_env)
  QD <- as.data.frame(do.call(rbind, QD))
  QD <- QD[, 2]
  
  slack <- QS - QD
  return(slack)
} 

QSQD_Equilib <- function(interval_P, QS_env, QD_env){
  
  P_E <- uniroot.all(equilib_rootfn,
                     interval_P,
                     lower = min(interval_P),
                     upper = max(interval_P),
                     QS_env = QS_env,
                     QD_env = QD_env)
  
  QS_vec <- QS_at_P(P_E, QS_env)
  
  return(QS_vec)
  
}


#=============================================================
#=============================================================
#=============================================================
# End function definitions
#=============================================================
#=============================================================
#=============================================================
# Define parameters
#-------------------------------------------------------------
# Supply
#-------------------------------------------------------------
mu_alpha <- -1000
cv_alpha <- 0.4
sig_alpha <- abs(mu_alpha * cv_alpha)
yCeil <- 44
m_A <- log(2)
cv_A <- 0.2
s_A <- m_A * cv_A
N <- 40
lq_bounds <- NULL
#-------------------------------------------------------------
# Demand
#-------------------------------------------------------------
P_output <- 23500
a_e <- 1.5 / 0.17
gamma_D <- 1.05
N_D <- 20
#=============================================================
P_vec <- seq(200, 3500, length.out = 200)
#=============================================================
# P <- 1800
# QS_at_P(P, mu_alpha, sig_alpha, yCeil, m_A, s_A, N)
QS_env <- list()
QS_env[["mu_alpha"]] <- mu_alpha
QS_env[["sig_alpha"]] <- sig_alpha
QS_env[["yCeil"]] <- yCeil
QS_env[["m_A"]] <- m_A
QS_env[["s_A"]] <- s_A
QS_env[["N"]] <- N
QS_env[["adopt_list"]] <- NULL
list_QS_curve <- QS_curve(P_vec, QS_env)
df_QS <- as.data.frame(do.call(rbind, list_QS_curve))
colnames(df_QS) <- c("Price (Baht / MT)", "Supply", "Market Participation")

QD_env <- list()
QD_env[["P_output"]] <- P_output
QD_env[["a_e"]] <- a_e
QD_env[["gamma_D"]] <- gamma_D
QD_env[["N_D"]] <- N_D
list_QD_curve <- QD_curve(P_vec, QD_env)
df_QD <- as.data.frame(do.call(rbind, list_QD_curve))
colnames(df_QD) <- c("Price (Baht / MT)", "Demand")
df_plot <- df_QS
# gg <- ggplot(df_plot, aes(x = Price, y = Supply))
# gg <- gg + geom_line()
# gg
# df_plot <- df_QD
# gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = Demand))
# gg <- gg + geom_line()
# gg

interval_P <- c(200, 3000)
equilib_vec <- QSQD_Equilib(interval_P, QS_env, QD_env)

df_plot <- merge(df_QS, df_QD)
df_plot$`Market Participation` <- NULL
df_plot <- df_plot %>% gather(Type, `Quantity (MT)`, Demand:Supply)

gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = `Quantity (MT)`, group = Type, color = Type))
gg <- gg + geom_line(lwd = 1)
gg <- gg + coord_cartesian(ylim = c(0, 3000))
gg <- gg + theme(legend.title = element_blank())
gg
#=============================================================
#=============================================================
delta <- 1.1
P_1 <- 2300
which_tech <- "baseline"
adopt_list <- list(delta, P_1, which_tech)
QS_env[["adopt_list"]] <- adopt_list
list_QS_curve <- QS_curve(P_vec, QS_env)
df_QS <- as.data.frame(do.call(rbind, list_QS_curve))
colnames(df_QS) <- c("Price (Baht / MT)", "Supply", "Market Participation")

df_plot <- df_QS %>% gather(Item, Value, Supply:`Market Participation`)
gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = Value))
gg <- gg + geom_line()
gg <- gg + geom_vline(xintercept = P_1 / delta, color = "violet", size = 1)
gg <- gg + facet_wrap(~Item, ncol = 1, scales = "free")
gg


which_tech <- "new"
adopt_list <- list(delta, P_1, which_tech)
QS_env[["adopt_list"]] <- adopt_list
QS_env[["mu_alpha"]] <- mu_alpha * delta
QS_env[["sig_alpha"]] <- abs(cv_alpha * mu_alpha * delta)
list_QS_curve <- QS_curve(P_vec, QS_env)
df_QS <- as.data.frame(do.call(rbind, list_QS_curve))
colnames(df_QS) <- c("Price (Baht / MT)", "Supply", "Market Participation")

df_plot <- df_QS %>% gather(Item, Value, Supply:`Market Participation`)
gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = Value))
gg <- gg + geom_line()
gg <- gg + facet_wrap(~Item, ncol = 1, scales = "free")
gg






#=============================================================
#=============================================================



