library(ggplot2)
library(rootSolve)
library(plyr)
library(dplyr)
library(tidyr)
library(fields)


plotSurface2 <- function (x, main = NULL, type = "C", zlab = NULL, xlab = NULL, 
                          ylab = NULL, levels = NULL, zlim = NULL, graphics.reset = NULL, 
                          labcex = 0.6, method = "flattest", add.legend = TRUE, ...) 
{
  obj <- x
  old.par <- par(no.readonly = TRUE)
  if (is.na(match(type, c("b", "c", "C", "I", "p")))) {
    stop("plot type does not match b, C, I, or p.")
  }
  if (is.null(zlim)) {
    zlim = range(obj$z, na.rm = TRUE)
  }
  if (is.null(graphics.reset) & (type == "b")) {
    graphics.reset <- TRUE
  }
  else {
    graphics.reset <- FALSE
  }
  if (graphics.reset) {
    on.exit(par(old.par))
  }
  if (is.null(xlab)) {
    if (is.null(obj$xlab)) 
      xlab <- "X"
    else xlab <- obj$xlab
  }
  if (is.null(ylab)) {
    if (is.null(obj$ylab)) 
      ylab <- "Y"
    else ylab <- obj$ylab
  }
  if (is.null(zlab)) {
    if (is.null(obj$zlab)) 
      zlab <- "Z"
    else zlab <- obj$zlab
  }
  if (is.null(main)) 
    if (!is.null(obj$main)) 
      main <- obj$main
  if (type == "b") 
    set.panel(1, 2, TRUE)
  if (type == "p" | type == "b") {
    if (type == "b") {
      add.legend <- FALSE
      old.mar <- par()$mar
      par(mar = c(0, 5, 0, 0))
    }
    drape.plot(obj, xlab = xlab, ylab = ylab, zlab = zlab, 
               zlim = zlim, add.legend = add.legend, ...)
    if (!is.null(main)) 
      title(main)
  }
  if (type == "I") {
    image.plot(obj$x, obj$y, obj$z, xlab = xlab, ylab = ylab, 
               zlim = zlim, ...)
    if ((!is.null(main)) & type != "b") 
      title(main)
  }
  if (type == "c") {
    if (is.null(levels)) 
      levels <- pretty(obj$z[!is.na(obj$z)], 5)
    contour(obj$x, obj$y, obj$z, levels = levels, labcex = labcex, 
            method = method, lwd = 2, ...)
    if ((!is.null(main)) & type != "b") 
      title(main)
  }
  if (type == "b" | type == "C") {
    if (type == "b") {
      par(mar = old.mar)
    }
    image.plot(obj$x, obj$y, obj$z, xlab = xlab, ylab = ylab, 
               graphics.reset = graphics.reset, zlim = zlim, ...)
    if (is.null(levels)) 
      levels <- pretty(obj$z[!is.na(obj$z)], 5)
    contour(obj$x, obj$y, obj$z, add = TRUE, levels = levels, 
            labcex = labcex, method = method, col = "black", lwd = 2)
    if ((!is.null(main)) & type != "b") 
      title(main)
  }
  invisible()
}

#==================================
#==================================
#==================================
#==================================
# get_rL0Lmax_01_DEM <- function(P_seq, interval_r = c(0, 1), P0, chng_DEM){
#   len_P_seq <- length(P_seq)
#   # r0_Lmax_vec_DEM <- c()
#   # r0_L0_vec_DEM <- c()
#   # r1_Lmax_vec_DEM <- c()
#   # r1_L0_vec_DEM <- c()
#   list_df <- list()
#   #--
#   for(i in 1:len_P_seq){
#     P1 <- P_seq[i]
#     # Get r range for this alternative price
#     df_out <- get_r0r1Range_DEM(P1, P0, interval_r, chng_DEM)
#     list_df[[i]] <- df_out
#     # r0_range_DEM <- out_list[[1]]
#     # r1_range_DEM <- out_list[[2]]
#     # r0_Lmax_vec_DEM[i] <- r0_range_DEM[1]
#     # r0_L0_vec_DEM[i] <- r0_range_DEM[2]
#     # r1_Lmax_vec_DEM[i] <- r1_range_DEM[1]
#     # r1_L0_vec_DEM[i] <- r1_range_DEM[2]
#   }
#   # out_df_rL0max01DEM <- data.frame(r0_Lmax_vec_DEM, r0_L0_vec_DEM,
#   #                                   r1_Lmax_vec_DEM, r1_L0_vec_DEM)
#   #                                   #rAdopt_vec_DEM)
#   # rL0_DEM <- ifelse(Market0, r0_L0_vec_DEM, r1_L0_vec_DEM)
#   # rLmax_DEM <- ifelse(Market0, r0_Lmax_vec_DEM, r1_Lmax_vec_DEM)
#   df_r01_L0Lmax_DEM <- do.call(rbind, list_df)
#   return(df_r01_L0Lmax_DEM)
# }
# 
# #==================================
# #==================================
# 
# get_rL0Lmax_01_SUP <- function(P_seq, interval_r = c(0, 1), P0, chng_SUP){
#   len_P_seq <- length(P_seq)
#   # r0_Lmax_vec_SUP <- c()
#   # r0_L0_vec_SUP <- c()
#   # r1_Lmax_vec_SUP <- c()
#   # r1_L0_vec_SUP <- c()
#   list_df <- list()
#   #--
#   for(i in 1:len_P_seq){
#     P1 <- P_seq[i]
#     list_df[[i]] <- get_r0r1Range_SUP(P1, P0, interval_r, chng_SUP)
#     # r0_range_SUP <- out_list[[1]]
#     # r1_range_SUP <- out_list[[2]]
#     # r0_Lmax_vec_SUP[i] <- r0_range_SUP[1]
#     # r0_L0_vec_SUP[i] <- r0_range_SUP[2]
#     # r1_Lmax_vec_SUP[i] <- r1_range_SUP[1]
#     # r1_L0_vec_SUP[i] <- r1_range_SUP[2]
#   }
#   # out_df_rL0max01SUP <- data.frame(r0_Lmax_vec_SUP, r0_L0_vec_SUP,
#   #                                   r1_Lmax_vec_SUP, r1_L0_vec_SUP)
#                                     #rAdopt_vec_SUP)
#   # rL0_SUP <- ifelse(Market0, r0_L0_vec_SUP, r1_L0_vec_SUP)
#   # rLmax_SUP <- ifelse(Market0, r0_Lmax_vec_SUP, r1_Lmax_vec_SUP)
#   df_r01_L0Lmax_SUP <- do.call(rbind, list_df)
#   return(df_r01_L0Lmax_SUP)
# }

#==================================
#==================================
rootfun <- function(P_rev_per_output_SUP,
                    N_S,
                    mu_P_fdstkCost_per_output_SUP,
                    cv_P_fdstkCost_per_output_SUP,
                    mu_P_procCost_per_output_SUP,
                    cv_P_procCost_per_output_SUP,
                    beta_SUP,
                    m_yCeil_SUP,
                    s2_yCeil_SUP,
                    m_A_SUP,
                    s2_A_SUP,
                    df_rL0max_SUP = NULL,
                    chng_SUP = 1,
                    #---
                    P_rev_per_output_DEM,
                    N_D,
                    mu_P_fdstkCost_per_output_DEM = NULL,
                    cv_P_fdstkCost_per_output_DEM = NULL,
                    mu_P_procCost_per_output_DEM,
                    cv_P_procCost_per_output_DEM,
                    beta_DEM,
                    m_yCeil_DEM,
                    s2_yCeil_DEM,
                    m_A_DEM,
                    s2_A_DEM,
                    df_rL0max_DEM = NULL,
                    chng_DEM = 1,
                    Market0, P_eq_00){
  #---
  if(is.null(df_rL0max_DEM)){
    P0 <- P_eq_00
    #out_df <- get_rL0Lmax_01_DEM(P_rev_per_output_SUP, interval_r = c(0, 1), P0, chng_DEM)
    P1_vec <- P_rev_per_output_SUP
    df_r01_L0max_DEM <- get_r01_L0max_DEM(P1_vec, P0, interval_r, chng_DEM)
    cond_DEM <- rep(Market0, nrow(df_r01_L0max_DEM))
    rL0_DEM <- ifelse(cond_DEM, df_r01_L0max_DEM$r0_L0_DEM, df_r01_L0max_DEM$r1_L0_DEM)
    rLmax_DEM <- ifelse(cond_DEM, df_r01_L0max_DEM$r0_Lmax_DEM, df_r01_L0max_DEM$r1_Lmax_DEM)
    df_rL0max_DEM <- data.frame(rL0 = rL0_DEM, rLmax = rLmax_DEM)
  }
  
  if(is.null(df_rL0max_SUP)){
    P0 <- P_eq_00
    #out_df <- get_rL0Lmax_01_SUP(P_rev_per_output_SUP, interval_r = c(0, 1), P0, chng_SUP)
    P1_vec <- P_rev_per_output_SUP
    df_r01_L0max_SUP <- get_r01_L0max_SUP(P1_vec, P0, interval_r, chng_SUP)
    cond_SUP <- rep(Market0, nrow(df_r01_L0max_SUP))
    rL0_SUP <- ifelse(cond_SUP, df_r01_L0max_SUP$r0_L0_SUP, df_r01_L0max_SUP$r1_L0_SUP)
    rLmax_SUP <- ifelse(cond_SUP, df_r01_L0max_SUP$r0_Lmax_SUP, df_r01_L0max_SUP$r1_Lmax_SUP)
    df_rL0max_SUP <- data.frame(rL0 = rL0_SUP, rLmax = rLmax_SUP)
  }
  
  #---
  df_QS <- Q_DorS(N = N_S,
                  P_rev_per_output = P_rev_per_output_SUP,
                  mu_P_fdstkCost_per_output = mu_P_fdstkCost_per_output_SUP,
                  mu_P_procCost_per_output = mu_P_procCost_per_output_SUP,
                  cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_SUP,
                  cv_P_procCost_per_output = cv_P_procCost_per_output_SUP,
                  beta = beta_SUP,
                  m_yCeil = m_yCeil_SUP,
                  s2_yCeil = s2_yCeil_SUP,
                  m_A = m_A_SUP,
                  s2_A = s2_A_SUP,
                  df_rL0max_SUP,
                  l_credit = 0)
  colnames(df_QS) <- c("Q", "mkt_particip")
  df_QS$Type <- "Supply"
  df_QS$P_rev_per_output_SUP <- P_rev_per_output_SUP
  #---
  df_QD <- Q_DorS(N = N_D,
                  P_rev_per_output = P_rev_per_output_DEM,
                  mu_P_fdstkCost_per_output = P_rev_per_output_SUP,
                  mu_P_procCost_per_output = mu_P_procCost_per_output_DEM,
                  cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM,
                  cv_P_procCost_per_output = cv_P_procCost_per_output_DEM,
                  beta = beta_DEM,
                  m_yCeil = m_yCeil_DEM,
                  s2_yCeil = s2_yCeil_DEM,
                  m_A = m_A_DEM,
                  s2_A = s2_A_DEM,
                  df_rL0max_DEM,
                  l_credit = 0)
  colnames(df_QD) <- c("Q", "mkt_particip")
  df_QD$Type <- "Demand"
  df_QD$P_rev_per_output_SUP <- P_rev_per_output_SUP
  #---
  df_QD$Q[which(df_QD$Q == 0)] <- NA
  df_QS$Q[which(df_QS$Q == 0)] <- NA
  d <- df_QS$Q - df_QD$Q
  #---
  # df_plot <- rbind(df_QS, df_QD)
  # gg <- ggplot(df_plot, aes(x = P_rev_per_output_SUP, y = Q, group = Type, color = Type))
  # gg <- gg + geom_point()
  # print(gg)
  return(d)
}
#==================================
#==================================
get_equilibrium_values <- function(interval_P,
                                   N_S,
                                   mu_P_fdstkCost_per_output_SUP,
                                   cv_P_fdstkCost_per_output_SUP,
                                   mu_P_procCost_per_output_SUP,
                                   cv_P_procCost_per_output_SUP,
                                   beta_SUP,
                                   m_yCeil_SUP,
                                   s2_yCeil_SUP,
                                   m_A_SUP,
                                   s2_A_SUP,
                                   df_rL0max_SUP = NULL,
                                   chng_SUP = 1,
                                   #---
                                   P_rev_per_output_DEM,
                                   N_D,
                                   mu_P_fdstkCost_per_output_DEM = NULL,
                                   cv_P_fdstkCost_per_output_DEM = NULL,
                                   mu_P_procCost_per_output_DEM,
                                   cv_P_procCost_per_output_DEM,
                                   beta_DEM,
                                   m_yCeil_DEM,
                                   s2_yCeil_DEM,
                                   m_A_DEM,
                                   s2_A_DEM,
                                   df_rL0max_DEM = NULL,
                                   chng_DEM = 1,
                                   Market0, P_eq_00,
                                   graph_on = F){
  #---
  interval_r = c(0, 1)
  #---
  # Note: chng_DEM/chng_SUP = NULL <--> chng_DEM/chng_SUP = 1
  # Note: If chng_DEM, chng_SUP not null and df_rL0max_DEM/SUP null, then Market0 must be either T or F (not null)
  # (chng_DEM, chng_SUP not null and df_rL0max_DEM/SUP null --> voluntary adoption)
  # (chng_DEM, chng_SUP not null and df_rL0max_DEM/SUP also not null --> involuntary adoption)
  # In the case of df_rL0max_DEM/SUP being null, then P_eq_00 must be provided
  if(chng_DEM != 1){
    baseline_mkt_before_adopt_DEM <- F
    if(!(is.null(df_rL0max_DEM))){
      #Involuntary adoption
      new_factry_efficiency <- 1 / beta_DEM * chng_DEM
      beta_DEM <- 1 / new_factry_efficiency
      adopt_voluntary_DEM <- F
    }else{
      #Voluntary adoption
      adopt_voluntary_DEM <- T
      if(Market0 == F){
        #Alternative market
        new_factry_efficiency <- 1 / beta_DEM * chng_DEM
        beta_DEM <- 1 / new_factry_efficiency
        
      }
    }
  }else{
    baseline_mkt_before_adopt_DEM <- T
  }
  
  if(chng_SUP != 1){
    baseline_mkt_before_adopt_SUP <- F
    if(!(is.null(df_rL0max_SUP))){
      #Involuntary adoption
      mu_P_fdstkCost_per_output_SUP <- mu_P_fdstkCost_per_output_SUP * chng_SUP
      adopt_voluntary_SUP <- F
    }else{
      #Voluntary adoption
      adopt_voluntary_SUP <- T
      if(Market0 == F){
        #Alternative market
        mu_P_fdstkCost_per_output_SUP <- mu_P_fdstkCost_per_output_SUP * chng_SUP
        
      }
    }
  }else{
    baseline_mkt_before_adopt_SUP <- T
  }
  #---
  Pe <- uniroot.all(rootfun, interval_P,
                    lower = min(interval_P), upper = max(interval_P),
                    N_S = N_S,
                    mu_P_fdstkCost_per_output_SUP = mu_P_fdstkCost_per_output_SUP,
                    cv_P_fdstkCost_per_output_SUP = cv_P_fdstkCost_per_output_SUP,
                    mu_P_procCost_per_output_SUP = mu_P_procCost_per_output_SUP,
                    cv_P_procCost_per_output_SUP = cv_P_procCost_per_output_SUP,
                    beta_SUP = beta_SUP,
                    m_yCeil_SUP = m_yCeil_SUP,
                    s2_yCeil_SUP = s2_yCeil_SUP,
                    m_A_SUP = m_A_SUP,
                    s2_A_SUP = s2_A_SUP,
                    df_rL0max_SUP = df_rL0max_SUP,
                    chng_SUP = chng_SUP,
                    #---
                    P_rev_per_output_DEM = P_rev_per_output_DEM,
                    N_D = N_D,
                    mu_P_fdstkCost_per_output_DEM = mu_P_fdstkCost_per_output_DEM,
                    cv_P_fdstkCost_per_output_DEM = cv_P_fdstkCost_per_output_DEM,
                    mu_P_procCost_per_output_DEM = mu_P_procCost_per_output_DEM,
                    cv_P_procCost_per_output_DEM = cv_P_procCost_per_output_DEM,
                    beta_DEM = beta_DEM,
                    m_yCeil_DEM = m_yCeil_DEM,
                    s2_yCeil_DEM = s2_yCeil_DEM,
                    m_A_DEM = m_A_DEM,
                    s2_A_DEM = s2_A_DEM,
                    df_rL0max_DEM = df_rL0max_DEM,
                    chng_DEM = chng_DEM,
                    Market0 = Market0, P_eq_00 = P_eq_00)
  #Equilibrium price(s), if any
  print(Pe)
  #---
  if(length(Pe) != 0){
    #Get equilibrium quantity and supply/demand mkt. participation
    if(is.null(df_rL0max_DEM)){
      P0 <- P_eq_00
      P1_vec <- Pe
      df_r01_L0max_DEM <- get_r01_L0max_DEM(P1_vec, P0, interval_r, chng_DEM)
      cond_DEM <- rep(Market0, nrow(df_r01_L0max_DEM))
      rL0_DEM <- ifelse(cond_DEM, df_r01_L0max_DEM$r0_L0_DEM, df_r01_L0max_DEM$r1_L0_DEM)
      rLmax_DEM <- ifelse(cond_DEM, df_r01_L0max_DEM$r0_Lmax_DEM, df_r01_L0max_DEM$r1_Lmax_DEM)
      df_rL0max_DEM_e <- data.frame(rL0 = rL0_DEM, rLmax = rLmax_DEM)
    }else{
      df_rL0max_DEM_e <- df_rL0max_DEM
      df_rL0max_DEM_graph <- df_rL0max_DEM
    }
    
    if(is.null(df_rL0max_SUP)){
      P0 <- P_eq_00
      #out_df <- get_rL0Lmax_01_SUP(P_seq, interval_r = c(0, 1), P0, chng_SUP)
      P1_vec <- Pe
      df_r01_L0max_SUP <- get_r01_L0max_SUP(P1_vec, P0, interval_r, chng_SUP)
      cond_SUP <- rep(Market0, nrow(df_r01_L0max_SUP))
      rL0_SUP <- ifelse(cond_SUP, df_r01_L0max_SUP$r0_L0_SUP, df_r01_L0max_SUP$r1_L0_SUP)
      rLmax_SUP <- ifelse(cond_SUP, df_r01_L0max_SUP$r0_Lmax_SUP, df_r01_L0max_SUP$r1_Lmax_SUP)
      df_rL0max_SUP_e <- data.frame(rL0 = rL0_SUP, rLmax = rLmax_SUP)
    }else{
      P1_vec <- seq(interval_P[1], interval_P[2], 10)
      df_rL0max_SUP_e <- df_rL0max_SUP
      df_rL0max_SUP_graph <- df_rL0max_SUP
    }
    #---
    df_QS <- Q_DorS(N = N_S,
                    P_rev_per_output = Pe,
                    mu_P_fdstkCost_per_output = mu_P_fdstkCost_per_output_SUP,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_SUP,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_SUP,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_SUP,
                    beta = beta_SUP,
                    m_yCeil = m_yCeil_SUP,
                    s2_yCeil = s2_yCeil_SUP,
                    m_A = m_A_SUP,
                    s2_A = s2_A_SUP,
                    df_rL0max_SUP_e,
                    l_credit = 0)
    colnames(df_QS) <- c("Q", "mkt_particip")
    df_QS$Type <- "Supply"
    df_QS$P <- Pe
    #---
    df_QD <- Q_DorS(N = N_D,
                    P_rev_per_output = P_rev_per_output_DEM,
                    mu_P_fdstkCost_per_output = Pe,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_DEM,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_DEM,
                    beta = beta_DEM,
                    m_yCeil = m_yCeil_DEM,
                    s2_yCeil = s2_yCeil_DEM,
                    m_A = m_A_DEM,
                    s2_A = s2_A_DEM,
                    df_rL0max_DEM_e,
                    l_credit = 0)
    colnames(df_QD) <- c("Q", "mkt_particip")
    df_QD$Type <- "Demand"
    df_QD$P <- Pe
    #---
    df_QD$Q[which(df_QD$Q == 0)] <- NA
    df_QS$Q[which(df_QS$Q == 0)] <- NA
    #---
    Qe <- df_QS$Q
    mkt_particip_DEM <- df_QD$mkt_particip
    mkt_particip_SUP <- df_QS$mkt_particip
    df_Eq <- data.frame(Pe = Pe, Qe = Qe, 
                        mkt_particip_SUP = mkt_particip_SUP,
                        mkt_particip_DEM = mkt_particip_DEM)
    df_Eq_r <- cbind(df_rL0max_SUP_e, df_rL0max_DEM_e)
    colnames(df_Eq_r)[1:2] <- paste0(colnames(df_Eq_r)[1:2], "_SUP")
    colnames(df_Eq_r)[3:4] <- paste0(colnames(df_Eq_r)[3:4], "_DEM")
  }else{
    df_Eq <- NULL
    df_Eq_r <- NULL
  }
  #---
  outlist <- list(df_Eq, df_Eq_r)
  #-----------------------------------
  if(graph_on){
    P1_vec <- seq(interval_P[1], interval_P[2], 10)
    if(is.null(df_rL0max_DEM)){
      P0 <- P_eq_00
      P1_vec <- seq(interval_P[1], interval_P[2], 10)
      df_r01_L0max_DEM <- get_r01_L0max_DEM(P1_vec, P0, interval_r, chng_DEM)
      cond_DEM <- rep(Market0, nrow(df_r01_L0max_DEM))
      rL0_DEM <- ifelse(cond_DEM, df_r01_L0max_DEM$r0_L0_DEM, df_r01_L0max_DEM$r1_L0_DEM)
      rLmax_DEM <- ifelse(cond_DEM, df_r01_L0max_DEM$r0_Lmax_DEM, df_r01_L0max_DEM$r1_Lmax_DEM)
      df_rL0max_DEM_graph <- data.frame(rL0 = rL0_DEM, rLmax = rLmax_DEM)
    }else{
      df_rL0max_DEM_graph <- df_rL0max_DEM
    }
    #---
    if(is.null(df_rL0max_SUP)){
      P0 <- P_eq_00
      P1_vec <- seq(interval_P[1], interval_P[2], 10)
      df_r01_L0max_SUP <- get_r01_L0max_SUP(P1_vec, P0, interval_r, chng_SUP)
      cond_SUP <- rep(Market0, nrow(df_r01_L0max_SUP))
      rL0_SUP <- ifelse(cond_SUP, df_r01_L0max_SUP$r0_L0_SUP, df_r01_L0max_SUP$r1_L0_SUP)
      rLmax_SUP <- ifelse(cond_SUP, df_r01_L0max_SUP$r0_Lmax_SUP, df_r01_L0max_SUP$r1_Lmax_SUP)
      df_rL0max_SUP_graph <- data.frame(rL0 = rL0_SUP, rLmax = rLmax_SUP)
    }else{
      df_rL0max_SUP_graph <- df_rL0max_SUP
    }
    #---
    df_QS <- Q_DorS(N = N_S,
                    P_rev_per_output = P1_vec,
                    mu_P_fdstkCost_per_output = mu_P_fdstkCost_per_output_SUP,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_SUP,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_SUP,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_SUP,
                    beta = beta_SUP,
                    m_yCeil = m_yCeil_SUP,
                    s2_yCeil = s2_yCeil_SUP,
                    m_A = m_A_SUP,
                    s2_A = s2_A_SUP,
                    df_rL0max_SUP_graph,
                    l_credit = 0)
    colnames(df_QS) <- c("Quantity (MT)", "mkt_particip")
    df_QS$Type <- "Supply"
    df_QS$`Price (lcu / MT)` <- P1_vec
    #---
    df_QD <- Q_DorS(N = N_D,
                    P_rev_per_output = P_rev_per_output_DEM,
                    mu_P_fdstkCost_per_output = P1_vec,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_DEM,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_DEM,
                    beta = beta_DEM,
                    m_yCeil = m_yCeil_DEM,
                    s2_yCeil = s2_yCeil_DEM,
                    m_A = m_A_DEM,
                    s2_A = s2_A_DEM,
                    df_rL0max_DEM_graph,
                    l_credit = 0)
    colnames(df_QD) <- c("Quantity (MT)", "mkt_particip")
    df_QD$Type <- "Demand"
    df_QD$`Price (lcu / MT)` <- P1_vec
    #---
    df_plot <- rbind(df_QD, df_QS)
    df_plot$`Quantity (MT)`[which(df_plot$`Quantity (MT)` == 0)] <- NA
    cond_baseline_mkt_before_adopt <- baseline_mkt_before_adopt_DEM | baseline_mkt_before_adopt_SUP
    if(cond_baseline_mkt_before_adopt == T){
      str_title <- "Baseline market (before release of new technology)"
    }else{
      cond_adopt_voluntary <- adopt_voluntary_DEM | adopt_voluntary_SUP
      if(cond_adopt_voluntary){
        str_title <- ifelse(Market0, "Baseline market, voluntary adoption", "Alternative market, voluntary adoption")
      }else{
        str_title <- "New market (involuntary adoption)"
      }
    }
    
    gg <- ggplot(df_plot, aes(x = `Price (lcu / MT)`, y = `Quantity (MT)`, group = Type, color = Type))
    gg <- gg + geom_line(lwd = 2)
    if(!(is.null(df_Eq))){
      # gg <- gg + geom_vline(xintercept = Pe, linetype = "dashed")
      # gg <- gg + geom_hline(yintercept = Qe, linetype = "dashed")
      #  gg <- gg + geom_point(data = data.frame(Pe, Qe), aes(x = Pe, y = Qe), size = 2.5, color = "green")
      gg <- gg + annotate("point", x = Pe, y = Qe, size = 2.5, color = "blue")
    }
    gg <- gg + ggtitle(str_title)
    print(gg)
    #---
  }
  #-----------------------------------
  return(outlist)
}

#==================================
#==================================
# Demand or supply function
#==================================
#==================================
#==================================
#==================================
#==================================
Q_DorS <- function(N, P_rev_per_output,
                   mu_P_fdstkCost_per_output,
                   mu_P_procCost_per_output = 0,
                   cv_P_fdstkCost_per_output,
                   cv_P_procCost_per_output = 0,
                   beta,
                   m_yCeil, s2_yCeil,
                   m_A, s2_A,
                   df_rL0max = data.frame(rL0 = 1, rLmax = 0),
                   l_credit = 0){
  #--------------------------------
  # mu_r
  ratio_price <- (mu_P_fdstkCost_per_output + mu_P_procCost_per_output) / P_rev_per_output
  mu_r <- ratio_price * beta * (1 - l_credit)
  #--------------------------------
  # sig2_r
  sig2_fdstkCost_per_output <- (mu_P_fdstkCost_per_output * cv_P_fdstkCost_per_output)^2
  sig2_procCost_per_output <- (mu_P_procCost_per_output * cv_P_procCost_per_output)^2
  sig2_r <- (sig2_fdstkCost_per_output + sig2_procCost_per_output) * (beta / P_rev_per_output)^2
  #--------------------------------
  # s_qStar
  s2_qStar <- s2_A + s2_yCeil + sig2_r
  s_qStar <- sqrt(s2_qStar)
  #--------------------------------
  # mu_qStar
  m_qStar <- m_A + m_yCeil - mu_r
  mu_qStar <- exp(m_qStar + s2_qStar / 2)
  #--------------------------------
  # Nvr0, Nvr1
  # Note: if sig2_beta = 0 then so should s2_yCeil, and N_D should = 1
  if(cv_P_fdstkCost_per_output != 0 | cv_P_procCost_per_output != 0){
    rL0 <- df_rL0max$rL0
    rLmax <- df_rL0max$rLmax
    vrLmax <- (-rLmax + mu_r - s2_qStar) / s_qStar
    vrL0 <- (-rL0 + mu_r - s2_qStar) / s_qStar
    NvrLmax <- pnorm(vrLmax)
    NvrL0 <- pnorm(vrL0)
    #--------------------------------
    # QD or QS
    #mkt_participation <- (1 + NvrLmax - NvrL0) / 2
    mkt_participation <- NvrLmax - NvrL0
    Q_D_or_S <- N * mu_qStar * mkt_participation
  }else{
    Q_D_or_S <- mu_qStar
  }
  #--------------------------------
  if(nrow(df_rL0max) > 1){
    # ind1 <- which(df_rL0max$rL0 == 0)
    # ind2 <- which(df_rL0max$rLmax == 0)
    # ind0 <- intersect(ind1, ind2)
    # Q_D_or_S[ind0] <- 0
    # mkt_participation[ind0] <- NA
  }else{
    if(rL0 == 0 & rLmax == 0){
      Q_D_or_S <- 0
      mkt_participation <- NA
    }
  }
  #--------------------------------
  df_out <- data.frame(Q_D_or_S, mkt_participation)
  #--------------------------------
  return(df_out)
}
#try it out:
# df_QS_e <- Q_DorS(N = N_S,
#                   P_input = 1,
#                   P_output = NA,
#                   mu_beta = mu_cost_per_farmProduct,
#                   sig2_beta = sig2_cost_per_farmProduct,
#                   m_yCeil = m_yCeil_farm,
#                   s2_yCeil = s2_yCeil_farm,
#                   m_A = m_A_farm,
#                   s2_A = s2_A_farm,
#                   df_rL0max = data.frame(rL0 = NA, rLmax = NA),
#                   l_credit = 0)

#==================================
#==================================
#==================================
#==================================
# Define net revenue functions for suppliers and demanders
# NR Demander (factory)
NRyd_DEM <- function(r, P, l_credit = 0){
  NR <- P * exp(-r) * (1 / r - 1)
  return(NR)
}
# NR Supplier (farm)
NRyd_SUP <- function(r, P, l_credit = 0){
  term <- r
  NR <- P * exp(-term) * (1 - term)
  return(NR)
}
#==================================
#==================================
#==================================
#==================================
# Define Demand and Supply NR0 - NR1 functions to feed into root solver
# Demand NR0 - NR1 function
NR0_minus_NR1_DEM <- function(rvec, P0, P1, chng_DEM, l_credit = 0, graph_only = F){
  r1 <- rvec * P1 / P0 * 1 / chng_DEM
  Baseline <- P0 * exp(-rvec) * (1 / rvec - 1)
  Alternative <- P1 * exp(-r1) * (1 / r1 - 1)
  NR0_minus_NR1 <- Baseline - Alternative
  if(graph_only == T){
    df_plot <- data.frame(rvec, Baseline, Alternative, Difference = NR0_minus_NR1)
    df_plot <- df_plot %>% gather(Type, `Net revenue`, Baseline:Difference)
    gg <- ggplot(df_plot, aes(x = rvec, y = `Net revenue`, group = Type, color = Type))
    gg <- gg + geom_line()
    gg <- gg + coord_cartesian(ylim = c(-1000, 3000), xlim = c(-1, 2.5))
    gg <- gg + geom_hline(yintercept = 0, color = "red")
    print(gg)
  }else{  
    return(NR0_minus_NR1)
  }
}
# Try it out
# chng_DEM <- chng_DEM_factry
# P0 <- Pe00
# P1 <- P_rev_per_output_SUP[5500]
# l_credit <- 0
# interval <- c(r0[1], r0[length(r0)])
# roots <- uniroot.all(NR0_minus_NR1_DEM, interval,
#                      lower = min(interval), upper = max(interval),
#                      P0 = P0, P1 = P1, chng_DEM = chng_DEM, l_credit = l_credit)
# roots
# NR0_minus_NR1_DEM(r0, P0, P1, chng_DEM, l_credit, graph_only = T)
#====================================
#====================================
#====================================
#====================================
# Supply NR0 - NR1 function
NR0_minus_NR1_SUP <- function(rvec, P0, P1, chng_SUP, l_credit = 0, graph_only = F){
  r1 <- rvec * P0 / P1 * chng_SUP
  Baseline <- P0 * exp(-rvec) * (1 - rvec)
  Alternative <- P1 * exp(-r1) * (1 - r1)
  NR0_minus_NR1 <- Baseline - Alternative
  if(graph_only == T){
    df_plot <- data.frame(rvec, Baseline, Alternative, Difference = NR0_minus_NR1)
    df_plot <- df_plot %>% gather(Type, `Net revenue`, Baseline:Difference)
    gg <- ggplot(df_plot, aes(x = rvec, y = `Net revenue`, group = Type, color = Type))
    gg <- gg + geom_line()
    gg <- gg + coord_cartesian(ylim = c(-1000, 3000), xlim = c(-1, 2.5))
    gg <- gg + geom_hline(yintercept = 0, color = "red")
    print(gg)
  }else{  
    return(NR0_minus_NR1)
  }
}
#Try it out
# chng_SUP <- chng_SUP_farm
# P0 <- Pe00
# P1 <- P_rev_per_output_SUP[4100]
# l_credit <- 0
# interval <- c(r0[1], r0[length(r0)])
# roots <- uniroot.all(NR0_minus_NR1_SUP, interval,
#                      lower = min(interval), upper = max(interval),
#                      P0 = P0, P1 = P1, chng_SUP = chng_SUP, l_credit = l_credit)
# roots
# NR0_minus_NR1_SUP(r0, P0, P1, chng_SUP, l_credit, graph_only = T)
#==================================
#==================================
#==================================
#==================================
#P1_vec = P_seq
get_r01_L0max_SUP <- function(P1_vec, P0, interval_r = c(0, 1), chng_SUP){
  outlist <- list()
  for(i in 1:length(P1_vec)){
    P1 <- P1_vec[i]
    roots <- uniroot.all(NR0_minus_NR1_SUP, interval_r,
                         lower = min(interval_r), upper = max(interval_r),
                         P0 = P0, P1 = P1, chng_SUP = chng_SUP)
    #print(roots)
    if(length(roots) == 0){root_keep <- NULL}else{
      root_keep <- roots[roots > 0 & roots < 1]
      if(length(root_keep) != 0){
        if(length(root_keep) > 1){print("SUP length(root_keep) > 1"); print(paste("chng_SUP =", chng_SUP))}
        if(root_keep < 10^-3 | root_keep > 998 * 10^-3){root_keep = NULL}
      }
    }
    #--
    if(length(root_keep) != 0){
      a_little_bit <- 0.001
      if(root_keep > 0.5){
        cond <- NR0_minus_NR1_SUP(root_keep - a_little_bit, P0, P1, chng_SUP) > 0
      }else{
        cond <- NR0_minus_NR1_SUP(root_keep + a_little_bit, P0, P1, chng_SUP) < 0
      }
      cond <- rep(cond, 2)
      r0_range <- ifelse(cond, c(0, root_keep), c(root_keep, 1))
      r1_range <- ifelse(cond, c(root_keep, 1), c(0, root_keep))
    }else{
      cond <- NR0_minus_NR1_SUP(0.5, P0, P1, chng_SUP) > 0
      cond <- rep(cond, 2)
      r0_range <- ifelse(cond, c(0, 1), c(0, 0))
      r1_range <- ifelse(cond, c(0, 0), c(0, 1))
    }
    this_df_r01_L0max_SUP <- data.frame(r0_L0_SUP = r0_range[2], r0_Lmax_SUP = r0_range[1],
                                        r1_L0_SUP = r1_range[2], r1_Lmax_SUP = r1_range[1])
    
    outlist[[i]] <- this_df_r01_L0max_SUP
    
  }
  df_r01_L0max_SUP <- do.call(rbind, outlist)
  return(df_r01_L0max_SUP)
}
#==================================
#==================================
#==================================
get_r01_L0max_DEM <- function(P1_vec, P0, interval_r = c(0, 1), chng_DEM){
  outlist <- list()
  for(i in 1:length(P1_vec)){
    P1 <- P1_vec[i]
    roots <- uniroot.all(NR0_minus_NR1_DEM, interval_r,
                         lower = min(interval_r), upper = max(interval_r),
                         P0 = P0, P1 = P1, chng_DEM = chng_DEM)
    if(length(roots) == 0){root_keep <- NULL}else{
      root_keep <- roots[roots > 0 & roots < 1]
      if(length(root_keep) != 0){
        if(length(root_keep) > 1){print("SUP length(root_keep) > 1"); print(paste("chng_SUP =", chng_SUP))}
        if(root_keep < 10^-3 | root_keep > 998 * 10^-3){root_keep = NULL}
      }
    }
    #--
    if(length(root_keep) != 0){
      a_little_bit <- 0.001
      if(root_keep > 0.5){
        cond <- NR0_minus_NR1_DEM(root_keep - a_little_bit, P0, P1, chng_DEM) > 0
      }else{
        cond <- NR0_minus_NR1_DEM(root_keep + a_little_bit, P0, P1, chng_DEM) < 0
      }
      cond <- rep(cond, 2)
      r0_range <- ifelse(cond, c(0, root_keep), c(root_keep, 1))
      r1_range <- ifelse(cond, c(root_keep, 1), c(0, root_keep))
    }else{
      cond <- NR0_minus_NR1_DEM(0.5, P0, P1, chng_DEM) > 0
      cond <- rep(cond, 2)
      r0_range <- ifelse(cond, c(0, 1), c(0, 0))
      r1_range <- ifelse(cond, c(0, 0), c(0, 1))
    }
    this_df_r01_L0max_DEM <- data.frame(r0_L0_DEM = r0_range[2], r0_Lmax_DEM = r0_range[1],
                                        r1_L0_DEM = r1_range[2], r1_Lmax_DEM = r1_range[1])
    
    outlist[[i]] <- this_df_r01_L0max_DEM
    
  }
  df_r01_L0max_DEM <- do.call(rbind, outlist)
  return(df_r01_L0max_DEM)
  
}
#==================================
#==================================
#==================================
#==================================
#==================================
#==================================
#==================================
#==================================
# (End function definition)
#==================================
#==================================
#==================================
#==================================
# Baseline market, before release of new tech
#==================================
# Define price range
P_rev_per_output_SUP <- seq(100, 4000, 10)
#==================================
# Demand side parameters
# Ethanol demand
P_ethanol_lcu_kL_statQuo <- 23500 #https://www.ceicdata.com/en/thailand/biofuel-reference-price/reference-price-ethanol-price-
MTRootsPerkLEthanol_statQuo <- 6 # 6 - Thierry (2014)
mu_Q_ethanol_kL_day_statQuo <- 200 # 150 -Thierry (2014) but hay also 8 new plants with 560 max cap
mu_Q_root_MT_day_ethanol_statQuo <- mu_Q_ethanol_kL_day_statQuo * MTRootsPerkLEthanol_statQuo
mu_cost_process_ethanol_lcu_kL_statQuo <- 9000 # 8806 Thierry (2014)
mu_cost_process_ethanol_lcu_MTRoots_statQuo <- mu_cost_process_ethanol_lcu_kL_statQuo / MTRootsPerkLEthanol_statQuo
cv_cost_process_ethanol_lcu_MTRoots_statQuo <- 0.08
N_D_factry_ethanol_statQuo <- 33 # 25 plus 8 under construction Thierry (2014)
m_yCeil_factry_ethanol_statQuo <- log(mu_Q_ethanol_kL_day_statQuo * 1.5)
cv_lyCeil_factry_ethanol_statQuo <- 0.15
# Starch demand
P_starch_lcu_MT_statQuo <- 14000
MTRootsPerMTStarch_statQuo <- 4.21 #Thierry interview
Q_root_MT_day_starch_statQuo <- 1200
Q_starch_MT_day_statQuo <- Q_root_MT_day_starch_statQuo / MTRootsPerMTStarch_statQuo
N_D_factry_starch_statQuo <- 10
cv_factryEfficiency_starch_statQuo <- 0.12
m_yCeil_factry_starch_statQuo <- log(Q_starch_MT_day_statQuo * 1.5)
cv_lyCeil_factry_starch_statQuo <- 0.5
#----------------------------------
N_D <- N_D_factry_ethanol_statQuo
P_rev_per_output_DEM_statQuo <- P_ethanol_lcu_kL_statQuo
beta_DEM_statQuo <- MTRootsPerkLEthanol_statQuo
mu_P_fdstkCost_per_output_DEM_statQuo <- NULL #In functions here input P_rev_output_SUP
cv_P_fdstkCost_per_output_DEM_statQuo <- 0 
mu_P_procCost_per_output_DEM_statQuo <- mu_cost_process_ethanol_lcu_MTRoots_statQuo
cv_P_procCost_per_output_DEM_statQuo <- cv_cost_process_ethanol_lcu_MTRoots_statQuo
m_yCeil_DEM_statQuo <- m_yCeil_factry_ethanol_statQuo
cv_lyCeil_DEM_statQuo <- cv_lyCeil_factry_ethanol_statQuo
s2_yCeil_DEM_statQuo <- (m_yCeil_DEM_statQuo * cv_lyCeil_DEM_statQuo)^2
m_A_DEM_statQuo <- 0
cv_lA_DEM_statQuo <- 0
s2_A_DEM_statQuo <- (m_A_DEM_statQuo * cv_lA_DEM_statQuo)^2
#==================================
# Supply side parameters
N_S_farm_statQuo <- 100
mu_cost_per_farmProduct_statQuo <- 1500 #850 Thierry (2014)
cv_cost_per_farmProduct_statQuo <- 0.2 #0.15 surmise
m_yCeil_farm_statQuo <- log(45) #log(43.8375)
cv_lyCeil_farm_statQuo <- 0
s2_yCeil_farm_statQuo <- (m_yCeil_farm_statQuo * cv_lyCeil_farm_statQuo)^2
m_A_farm_statQuo <- log(1.25) # log(4.673574) Thierry data, 0.5-2 Thierry (2014)
cv_lA_farm_statQuo <- 0.55 #0.5466573 Thierry data
s2_A_farm_statQuo <- (m_A_farm_statQuo * cv_lA_farm_statQuo)^2
#----------------------------------
N_S <- N_S_farm_statQuo
beta_SUP_statQuo <- 1
mu_P_fdstkCost_per_output_SUP_statQuo <- mu_cost_per_farmProduct_statQuo
cv_P_fdstkCost_per_output_SUP_statQuo <- cv_cost_per_farmProduct_statQuo
mu_P_procCost_per_output_SUP_statQuo <- 0
cv_P_procCost_per_output_SUP_statQuo <- 0
m_yCeil_SUP_statQuo <- m_yCeil_farm_statQuo
cv_lyCeil_SUP_statQuo <- cv_lyCeil_farm_statQuo
s2_yCeil_SUP_statQuo <- (m_yCeil_SUP_statQuo * cv_lyCeil_SUP_statQuo)^2
m_A_SUP_statQuo <- m_A_farm_statQuo
cv_lA_SUP_statQuo <- cv_lA_farm_statQuo
s2_A_SUP_statQuo <- (m_A_SUP_statQuo * cv_lA_SUP_statQuo)^2
#==================================
#==================================
# df_table <- data.frame(Ethanol_price_lcu_kL = P_ethanol_lcu_kL_statQuo,
#                        Number_factories = N_D,
#                        Productivity_MTrootsTokL = 1 / beta_DEM_statQuo,
#                        Mean_processing_cost = mu_cost_process_ethanol_lcu_kL_statQuo,
#                        CV_processing_cost = cv_cost_process_ethanol_lcu_MTRoots_statQuo,
#                        Mean_logged_maxcapacity = m_yCeil_factry_ethanol_statQuo,
#                        CV_logged_maxcapacity = cv_lyCeil_factry_ethanol_statQuo,
#                        Number_farms = N_S,
#                        Mean_cost_per_farmProduct = mu_cost_per_farmProduct_statQuo,
#                        CV_cost_per_farmProduct = cv_cost_per_farmProduct_statQuo,
#                        Mean_logged_maxyield = m_yCeil_farm,
#                        CV_logged_maxyield = cv_lyCeil_farm,
#                        Mean_logged_area = m_A_farm,
#                        CV_logged_area = cv_lA_farm)
# df_table <- as.data.frame(t(df_table))
# write.csv(df_table, "RTB DEPEMap Study.csv")
#==================================
#==================================
#==================================
#==================================
# Baseline Demand curve plot
graph_on <- F
#==================================
df_rL0max <- data.frame(rL0 = 1, rLmax = 0)
df_QD00 <- Q_DorS(N = N_D,
                  P_rev_per_output = P_rev_per_output_DEM_statQuo,
                  mu_P_fdstkCost_per_output = P_rev_per_output_SUP,
                  mu_P_procCost_per_output = mu_P_procCost_per_output_DEM_statQuo,
                  cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM_statQuo,
                  cv_P_procCost_per_output = cv_P_procCost_per_output_DEM_statQuo,
                  beta = beta_DEM_statQuo,
                  m_yCeil = m_yCeil_DEM_statQuo,
                  s2_yCeil = s2_yCeil_DEM_statQuo,
                  m_A = m_A_DEM_statQuo,
                  s2_A = s2_A_DEM_statQuo,
                  df_rL0max,
                  l_credit = 0)
colnames(df_QD00) <- c("Demand (MT)", "Demand Market Participation")
df_QD00$`Root Price (lcu / MT)` <- P_rev_per_output_SUP
if(graph_on == T){
  df_plot <- df_QD00
  gathercols <- colnames(df_plot)[1:2]
  df_plot <- df_plot %>% gather_("Type", "Value", gathercols)
  gg <- ggplot(df_plot, aes(x = `Root Price (lcu / MT)`, y = Value))
  gg <- gg + geom_line(lwd = 2)
  gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free",
                        strip.position = "left")
  gg <- gg + ylab(NULL)
  gg <- gg + theme_bw()
  gg
  
}
#==================================
# Explore demand curve sensitivity
#---
# to changes in mean conversion efficiency
turn_on <- F
#----------------------------------
if(turn_on == T){
  eta_vec <- seq(-0.4, 0.4, 0.2)
  dfQD_list <- list()
  for(i in 1:length(eta_vec)){
    this_eta_DEM <- eta_vec[i]
    this_chng_DEM <- 1 + this_eta_DEM
    new_factry_efficiency <- 1 / beta_DEM_statQuo * this_chng_DEM
    this_beta_DEM <- 1 / new_factry_efficiency
    df_QD <- Q_DorS(N = N_D,
                    P_rev_per_output = P_rev_per_output_DEM,
                    mu_P_fdstkCost_per_output = P_rev_per_output_SUP,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_DEM_statQuo,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM_statQuo,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_DEM_statQuo,
                    beta = this_beta_DEM,
                    m_yCeil = m_yCeil_DEM_statQuo,
                    s2_yCeil = s2_yCeil_DEM_statQuo,
                    m_A = m_A_DEM_statQuo,
                    s2_A = s2_A_DEM_statQuo,
                    df_rL0max,
                    l_credit = 0)
    df_QD$`Feedstock Price (lcu / MT)` <- P_rev_per_output_SUP
    df_QD$`Productivity\n(L / kg Roots)` <- as.character(round(new_factry_efficiency, 2))
    dfQD_list[[i]] <- df_QD
    
  }
  df_QD <- do.call(rbind, dfQD_list)
  colnames(df_QD)[1:2] <- c("Demand (MT)", "Demand Market Participation")
  # df_plot <- df_QD
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Demand (MT)`, group = `Mean Conversion\nEfficiency`, color = `Mean Conversion\nEfficiency`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Demand Market Participation`, group = `Mean Conversion\nEfficiency`, color = `Mean Conversion\nEfficiency`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  df_QD_factryEfficiency <- df_QD
  gathercols <- colnames(df_QD_factryEfficiency)[1:2]
  df_QD_factryEfficiency <- df_QD_factryEfficiency %>% gather_("Type", "Value", gathercols)
  gg <- ggplot(df_QD_factryEfficiency, aes(x = `Feedstock Price (lcu / MT)`, y = Value,
                                           group = `Productivity\n(L / kg Roots)`,
                                           color = `Productivity\n(L / kg Roots)`))
  gg <- gg + geom_line(lwd = 2)
  gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free",
                        strip.position = "left")
  gg <- gg + ylab(NULL)
  gg
  
}
#----------------------------------
# to changes in variance (cv) of processing cost
turn_on <- F
#----------------------------------
if(turn_on == T){
  eta_vec <- seq(0.1, 1.1, 0.3)
  dfQD_list <- list()
  for(i in 1:length(eta_vec)){
    this_eta_DEM <- eta_vec[i]
    this_cv_P_procCost_per_output_DEM <- cv_P_procCost_per_output_DEM_statQuo + this_eta_DEM
    df_QD <- Q_DorS(N = N_D,
                    P_rev_per_output = P_rev_per_output_DEM,
                    mu_P_fdstkCost_per_output = P_rev_per_output_SUP,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_DEM_statQuo,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM_statQuo,
                    cv_P_procCost_per_output = this_cv_P_procCost_per_output_DEM,
                    beta = beta_DEM_statQuo,
                    m_yCeil = m_yCeil_DEM_statQuo,
                    s2_yCeil = s2_yCeil_DEM_statQuo,
                    m_A = m_A_DEM_statQuo,
                    s2_A = s2_A_DEM_statQuo,
                    df_rL0max,
                    l_credit = 0)
    df_QD$`CV Processing\nCost` <- as.character(this_cv_P_procCost_per_output_DEM)
    dfQD_list[[i]] <- df_QD
    
  }
  df_QD <- do.call(rbind, dfQD_list)
  colnames(df_QD)[1:2] <- c("Demand (MT)", "Demand Market Participation")
  df_QD$`Feedstock Price (lcu / MT)` <- P_rev_per_output_SUP
  # df_plot <- df_QD
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Demand (MT)`, group = `CV Conversion\nEfficiency`, color = `CV Conversion\nEfficiency`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Demand Market Participation`, group = `CV Conversion\nEfficiency`, color = `CV Conversion\nEfficiency`))
  # gg <- gg + geom_line(lwd = 2)
  # gg  
  df_QD_factryProcCost <- df_QD
  gathercols <- colnames(df_QD_factryProcCost)[1:2]
  df_QD_factryProcCost <- df_QD_factryProcCost %>% gather_("Type", "Value", gathercols)
  gg <- ggplot(df_QD_factryProcCost, aes(x = `Feedstock Price (lcu / MT)`, y = Value,
                                         group = `CV Processing\nCost`,
                                         color = `CV Processing\nCost`))
  gg <- gg + geom_line(lwd = 2)
  gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free",
                        strip.position = "left")
  gg <- gg + ylab(NULL)
  gg
}
#----------------------------------
# to changes in mean factory capacity
turn_on <- F
#----------------------------------
if(turn_on == T){
  eta_vec <- seq(0.2, 0.9, 0.2)
  dfQD_list <- list()
  for(i in 1:length(eta_vec)){
    this_eta_DEM <- eta_vec[i]
    this_m_yCeil_DEM <- m_yCeil_DEM_statQuo + this_eta_DEM
    this_s2_yCeil_DEM <- (cv_lyCeil_DEM_statQuo * this_m_yCeil_DEM)^2
    df_QD <- Q_DorS(N = N_D,
                    P_rev_per_output = P_rev_per_output_DEM,
                    mu_P_fdstkCost_per_output = P_rev_per_output_SUP,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_DEM_statQuo,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM_statQuo,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_DEM_statQuo,
                    beta = beta_DEM_statQuo,
                    m_yCeil = this_m_yCeil_DEM,
                    s2_yCeil = this_s2_yCeil_DEM,
                    m_A = m_A_DEM_statQuo,
                    s2_A = s2_A_DEM_statQuo,
                    df_rL0max,
                    l_credit = 0)
    df_QD$`Mean\nMax Factory\nCapacity\n(logged kL)` <- as.character(round(this_m_yCeil_DEM, 2))
    dfQD_list[[i]] <- df_QD
    
  }
  df_QD <- do.call(rbind, dfQD_list)
  colnames(df_QD)[1:2] <- c("Demand (MT)", "Demand Market Participation")
  df_QD$`Feedstock Price (lcu / MT)` <- P_rev_per_output_SUP
  # df_plot <- df_QD
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Demand (MT)`, group = `Mean (logged)\nFactory Capacity`, color = `Mean (logged)\nFactory Capacity`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Demand Market Participation`, group = `Mean (logged)\nFactory Capacity`, color = `Mean (logged)\nFactory Capacity`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  df_QD_factryMaxCap <- df_QD
  gathercols <- colnames(df_QD_factryMaxCap)[1:2]
  df_QD_factryMaxCap <- df_QD_factryMaxCap %>% gather_("Type", "Value", gathercols)
  gg <- ggplot(df_QD_factryMaxCap, aes(x = `Feedstock Price (lcu / MT)`, y = Value,
                                       group = `Mean\nMax Factory\nCapacity\n(logged kL)`,
                                       color = `Mean\nMax Factory\nCapacity\n(logged kL)`))
  gg <- gg + geom_line(lwd = 2)
  gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free",
                        strip.position = "left")
  gg <- gg + ylab(NULL)
  gg
}
#----------------------------------
# to changes in variance (cv) of factory capacity
#----------------------------------
turn_on <- F
if(turn_on == T){
  eta_vec <- seq(0.05, 0.2, 0.05)
  dfQD_list <- list()
  for(i in 1:length(eta_vec)){
    this_eta_DEM <- eta_vec[i]
    this_cv_lyCeil_DEM <- cv_lyCeil_DEM_statQuo + this_eta_DEM
    this_s2_yCeil_DEM <- (this_cv_lyCeil_DEM * m_yCeil_DEM_statQuo)^2
    df_QD <- Q_DorS(N = N_D,
                    P_rev_per_output = P_rev_per_output_DEM,
                    mu_P_fdstkCost_per_output = P_rev_per_output_SUP,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_DEM_statQuo,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM_statQuo,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_DEM_statQuo,
                    beta = beta_DEM_statQuo,
                    m_yCeil = m_yCeil_DEM_statQuo,
                    s2_yCeil = this_s2_yCeil_DEM,
                    m_A = m_A_DEM_statQuo,
                    s2_A = s2_A_DEM_statQuo,
                    df_rL0max,
                    l_credit = 0)
    df_QD$`CV (logged)\nMax Factory\nCapacity` <- as.character(this_cv_lyCeil_DEM)
    dfQD_list[[i]] <- df_QD
    
  }
  df_QD <- do.call(rbind, dfQD_list)
  colnames(df_QD)[1:2] <- c("Demand (MT)", "Demand Market Participation")
  df_QD$`Feedstock Price (lcu / MT)` <- P_rev_per_output_SUP
  # df_plot <- df_QD
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Demand (MT)`, group = `CV (logged)\nFactory Capacity`, color = `CV (logged)\nFactory Capacity`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Demand Market Participation`, group = `CV (logged)\nFactory Capacity`, color = `CV (logged)\nFactory Capacity`))
  # gg <- gg + geom_line(lwd = 2)
  # gg  
  df_QD_factryMaxCapCV <- df_QD
  gathercols <- colnames(df_QD_factryMaxCapCV)[1:2]
  df_QD_factryMaxCapCV <- df_QD_factryMaxCapCV %>% gather_("Type", "Value", gathercols)
  gg <- ggplot(df_QD_factryMaxCapCV, aes(x = `Feedstock Price (lcu / MT)`, y = Value,
                                         group = `CV (logged)\nMax Factory\nCapacity`,
                                         color = `CV (logged)\nMax Factory\nCapacity`))
  gg <- gg + geom_line(lwd = 2)
  gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free",
                        strip.position = "left")
  gg <- gg + ylab(NULL)
  gg
  
}

#----------------------------------
# to changes in expected output price
turn_on <- F
#----------------------------------
if(turn_on == T){
  eta_vec <- seq(-0.2, 0.2, 0.1)
  dfQD_list <- list()
  for(i in 1:length(eta_vec)){
    this_eta_DEM <- eta_vec[i]
    chng_DEM <- 1 + this_eta_DEM
    this_P_rev_per_output_DEM <- P_rev_per_output_DEM_statQuo * chng_DEM
    df_QD <- Q_DorS(N = N_D,
                    P_rev_per_output = this_P_rev_per_output_DEM,
                    mu_P_fdstkCost_per_output = P_rev_per_output_SUP,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_DEM_statQuo,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM_statQuo,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_DEM_statQuo,
                    beta = beta_DEM_statQuo,
                    m_yCeil = m_yCeil_DEM_statQuo,
                    s2_yCeil = s2_yCeil_DEM_statQuo,
                    m_A = m_A_DEM_statQuo,
                    s2_A = s2_A_DEM_statQuo,
                    df_rL0max,
                    l_credit = 0)
    df_QD$`Ethanol\nPrice\n(lcu / kL)` <- as.character(this_P_rev_per_output_DEM)
    dfQD_list[[i]] <- df_QD
    
  }
  df_QD <- do.call(rbind, dfQD_list)
  colnames(df_QD)[1:2] <- c("Demand (MT)", "Demand Market Participation")
  df_QD$`Feedstock Price (lcu / MT)` <- P_rev_per_output_SUP
  # df_plot <- df_QD
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Demand (MT)`, group = `Output Price\n(lcu / kL)`, color = `Output Price\n(lcu / kL)`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Demand Market Participation`, group = `Output Price\n(lcu / kL)`, color = `Output Price\n(lcu / kL)`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  df_QD_factryPrice <- df_QD
  gathercols <- colnames(df_QD_factryPrice)[1:2]
  df_QD_factryPrice <- df_QD_factryPrice %>% gather_("Type", "Value", gathercols)
  gg <- ggplot(df_QD_factryPrice, aes(x = `Feedstock Price (lcu / MT)`, y = Value,
                                      group = `Ethanol\nPrice\n(lcu / kL)`,
                                      color = `Ethanol\nPrice\n(lcu / kL)`))
  gg <- gg + geom_line(lwd = 2)
  gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free",
                        strip.position = "left")
  gg <- gg + ylab(NULL)
  gg
  
}
#==================================
#==================================
#==================================
#==================================
#==================================
#==================================
# Baseline Supply curve plot
#==================================
df_rL0max <- data.frame(rL0 = 1, rLmax = 0)
df_QS00 <- Q_DorS(N = N_S,
                  P_rev_per_output = P_rev_per_output_SUP,
                  mu_P_fdstkCost_per_output = mu_P_fdstkCost_per_output_SUP_statQuo,
                  mu_P_procCost_per_output = mu_P_procCost_per_output_SUP_statQuo,
                  cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_SUP_statQuo,
                  cv_P_procCost_per_output = cv_P_procCost_per_output_SUP_statQuo,
                  beta = beta_SUP_statQuo,
                  m_yCeil = m_yCeil_SUP_statQuo,
                  s2_yCeil = s2_yCeil_SUP_statQuo,
                  m_A = m_A_SUP_statQuo,
                  s2_A = s2_A_SUP_statQuo,
                  df_rL0max,
                  l_credit = 0)
colnames(df_QS00) <- c("Supply (MT)", "Supply Market Participation")
df_QS00$`Root Price (lcu / MT)` <- P_rev_per_output_SUP
graph_on <- F
if(graph_on == T){
  df_plot <- df_QS00
  gathercols <- colnames(df_plot)[1:2]
  df_plot <- df_plot %>% gather_("Type", "Value", gathercols)
  gg <- ggplot(df_plot, aes(x = `Root Price (lcu / MT)`, y = Value))
  gg <- gg + geom_line(lwd = 2)
  gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free",
                        strip.position = "left")
  gg <- gg + ylab(NULL)
  gg <- gg + theme_bw()
  gg
}
#==================================
# Explore supply curve sensitivity
#---
# to changes in mean cost per farm output
#----------------------------------
turn_on <- F
if(turn_on == T){
  P_rev_per_output_SUP <- seq(100, 5000, 10)
  eta_vec <- seq(-0.3, 0.6, 0.3)
  dfQS_list <- list()
  for(i in 1:length(eta_vec)){
    this_eta_SUP <- eta_vec[i]
    chng_SUP <- 1 + this_eta_SUP
    this_mu_P_fdstkCost_per_output_SUP <- mu_P_fdstkCost_per_output_SUP_statQuo * chng_SUP
    df_QS <- Q_DorS(N = N_S,
                    P_rev_per_output = P_rev_per_output_SUP,
                    mu_P_fdstkCost_per_output = this_mu_P_fdstkCost_per_output_SUP,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_SUP_statQuo,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_SUP_statQuo,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_SUP_statQuo,
                    beta = beta_SUP_statQuo,
                    m_yCeil = m_yCeil_SUP_statQuo,
                    s2_yCeil = s2_yCeil_SUP_statQuo,
                    m_A = m_A_SUP_statQuo,
                    s2_A = s2_A_SUP_statQuo,
                    df_rL0max,
                    l_credit = 0)
    df_QS$`Mean Farm\nCost Per\nUnit Output\n(lcu / MT)` <- factor(round(this_mu_P_fdstkCost_per_output_SUP, 0))
    dfQS_list[[i]] <- df_QS
    
  }
  df_QS <- do.call(rbind, dfQS_list)
  colnames(df_QS)[1:2] <- c("Supply (MT)", "Supply Market Participation")
  df_QS$`Feedstock Price (lcu / MT)` <- P_rev_per_output_SUP
  # df_plot <- df_QS
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Supply (MT)`, group = `Mean Cost\nPer Unit\nFarm Output\n(lcu)`, color = `Mean Cost\nPer Unit\nFarm Output\n(lcu)`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Supply Market Participation`, group = `Mean Cost\nPer Unit\nFarm Output\n(lcu)`, color = `Mean Cost\nPer Unit\nFarm Output\n(lcu)`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  gathercols <- colnames(df_QS)[1:2]
  df_QS_farmCost <- df_QS %>% gather_("Type", "Value", gathercols)
  gg <- ggplot(df_QS_farmCost, aes(x = `Feedstock Price (lcu / MT)`, y = Value,
                                   group = `Mean Farm\nCost Per\nUnit Output\n(lcu / MT)`,
                                   color = `Mean Farm\nCost Per\nUnit Output\n(lcu / MT)`))
  gg <- gg + geom_line(lwd = 2)
  gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free",
                        strip.position = "left")
  gg <- gg + ylab(NULL)
  gg
}
#----------------------------------
# to changes in variance (cv) of farm cost per unit output
#----------------------------------
turn_on <- F
if(turn_on == T){
  P_rev_per_output_SUP <- seq(150, 5000, 10)
  eta_vec <- seq(-0.1, 0.8, 0.3)
  dfQS_list <- list()
  for(i in 1:length(eta_vec)){
    this_eta_SUP <- eta_vec[i]
    this_cv_P_fdstkCost_per_output_SUP <- cv_P_fdstkCost_per_output_SUP_statQuo + this_eta_SUP
    df_QS <- Q_DorS(N = N_S,
                    P_rev_per_output = P_rev_per_output_SUP,
                    mu_P_fdstkCost_per_output = mu_P_fdstkCost_per_output_SUP_statQuo,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_SUP_statQuo,
                    cv_P_fdstkCost_per_output = this_cv_P_fdstkCost_per_output_SUP,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_SUP_statQuo,
                    beta = beta_SUP_statQuo,
                    m_yCeil = m_yCeil_SUP_statQuo,
                    s2_yCeil = s2_yCeil_SUP_statQuo,
                    m_A = m_A_SUP_statQuo,
                    s2_A = s2_A_SUP_statQuo,
                    df_rL0max,
                    l_credit = 0)
    df_QS$`CV Farm\nCost Per\nUnit Output` <- factor(this_cv_P_fdstkCost_per_output_SUP)
    dfQS_list[[i]] <- df_QS
  }
  df_QS <- do.call(rbind, dfQS_list)
  colnames(df_QS)[1:2] <- c("Supply (MT)", "Supply Market Participation")
  df_QS$`Feedstock Price (lcu / MT)` <- P_rev_per_output_SUP
  # df_plot <- df_QS
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Supply (MT)`, group = `CV Cost\nPer Unit\nFarm Output\n(lcu)`, color = `CV Cost\nPer Unit\nFarm Output\n(lcu)`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Supply Market Participation`, group = `CV Cost\nPer Unit\nFarm Output\n(lcu)`, color = `CV Cost\nPer Unit\nFarm Output\n(lcu)`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  gathercols <- colnames(df_QS)[1:2]
  df_QS_farmCostCV <- df_QS %>% gather_("Type", "Value", gathercols)
  gg <- ggplot(df_QS_farmCostCV, aes(x = `Feedstock Price (lcu / MT)`, y = Value,
                                     group = `CV Farm\nCost Per\nUnit Output`,
                                     color = `CV Farm\nCost Per\nUnit Output`))
  gg <- gg + geom_line(lwd = 2)
  gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free",
                        strip.position = "left")
  gg <- gg + ylab(NULL)
  gg
  
}
#----------------------------------
# to changes in mean farm size
#----------------------------------
turn_on <- F
if(turn_on == T){
  eta_vec <- seq(-0.2, 0.1, 0.1)
  dfQS_list <- list()
  for(i in 1:length(eta_vec)){
    this_eta_SUP <- eta_vec[i]
    chng_SUP <- 1 + this_eta_SUP
    this_m_A_SUP <- m_A_SUP_statQuo * chng_SUP
    this_s2_A_SUP <- (cv_lA_SUP_statQuo * this_m_A_SUP)^2
    df_QS <- Q_DorS(N = N_S,
                    P_rev_per_output = P_rev_per_output_SUP,
                    mu_P_fdstkCost_per_output = mu_P_fdstkCost_per_output_SUP_statQuo,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_SUP_statQuo,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_SUP_statQuo,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_SUP_statQuo,
                    beta = beta_SUP_statQuo,
                    m_yCeil = m_yCeil_SUP_statQuo,
                    s2_yCeil = s2_yCeil_SUP_statQuo,
                    m_A = this_m_A_SUP,
                    s2_A = this_s2_A_SUP,
                    df_rL0max,
                    l_credit = 0)
    df_QS$`Mean Farm\nSize (Ha.)` <- factor(round(exp(this_m_A_SUP), 1))
    dfQS_list[[i]] <- df_QS
    
  }
  df_QS <- do.call(rbind, dfQS_list)
  colnames(df_QS)[1:2] <- c("Supply (MT)", "Supply Market Participation")
  df_QS$`Feedstock Price (lcu / MT)` <- P_rev_per_output_SUP
  # df_plot <- df_QS
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Supply (MT)`, group = `Mean (logged)\nFarm Size (Ha.)`, color = `Mean (logged)\nFarm Size (Ha.)`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Supply Market Participation`, group = `Mean (logged)\nFarm Size (Ha.)`, color = `Mean (logged)\nFarm Size (Ha.)`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  gathercols <- colnames(df_QS)[1:2]
  df_QS_farmSize <- df_QS %>% gather_("Type", "Value", gathercols)
  gg <- ggplot(df_QS_farmSize, aes(x = `Feedstock Price (lcu / MT)`, y = Value,
                                   group = `Mean Farm\nSize (Ha.)`,
                                   color = `Mean Farm\nSize (Ha.)`))
  gg <- gg + geom_line(lwd = 2)
  gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free",
                        strip.position = "left")
  gg <- gg + ylab(NULL)
  gg
  
}
#----------------------------------
# to changes in variance (cv) of farm size
#----------------------------------
turn_on <- F
if(turn_on == T){
  eta_vec <- seq(-0.2, 0.1, 0.1)
  dfQS_list <- list()
  for(i in 1:length(eta_vec)){
    this_eta_SUP <- eta_vec[i]
    this_cv_lA_SUP <- cv_lA_SUP_statQuo + this_eta_SUP
    this_s2_A_SUP <- (this_cv_lA_SUP * m_A_SUP_statQuo)^2
    df_QS <- Q_DorS(N = N_S,
                    P_rev_per_output = P_rev_per_output_SUP,
                    mu_P_fdstkCost_per_output = mu_P_fdstkCost_per_output_SUP_statQuo,
                    mu_P_procCost_per_output = mu_P_procCost_per_output_SUP_statQuo,
                    cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_SUP_statQuo,
                    cv_P_procCost_per_output = cv_P_procCost_per_output_SUP_statQuo,
                    beta = beta_SUP_statQuo,
                    m_yCeil = m_yCeil_SUP_statQuo,
                    s2_yCeil = s2_yCeil_SUP_statQuo,
                    m_A = m_A_SUP_statQuo,
                    s2_A = this_s2_A_SUP,
                    df_rL0max,
                    l_credit = 0)
    df_QS$`CV Farm\nSize (logged)` <- factor(round(this_cv_lA_SUP, 1))
    dfQS_list[[i]] <- df_QS
    
  }
  df_QS <- do.call(rbind, dfQS_list)
  colnames(df_QS)[1:2] <- c("Supply (MT)", "Supply Market Participation")
  df_QS$`Feedstock Price (lcu / MT)` <- P_rev_per_output_SUP
  # df_plot <- df_QS
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Supply (MT)`, group = `CV (logged)\nFarm Size (Ha.)`, color = `CV (logged)\nFarm Size (Ha.)`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  # gg <- ggplot(df_plot, aes(x = `Feedstock Price (lcu / MT)`, y = `Supply Market Participation`, group = `CV (logged)\nFarm Size (Ha.)`, color = `CV (logged)\nFarm Size (Ha.)`))
  # gg <- gg + geom_line(lwd = 2)
  # gg
  gathercols <- colnames(df_QS)[1:2]
  df_QS_farmSizeCV <- df_QS %>% gather_("Type", "Value", gathercols)
  gg <- ggplot(df_QS_farmSizeCV, aes(x = `Feedstock Price (lcu / MT)`, y = Value,
                                     group = `CV Farm\nSize (logged)`,
                                     color = `CV Farm\nSize (logged)`))
  gg <- gg + geom_line(lwd = 2)
  gg <- gg + facet_wrap(~Type, ncol = 1, scales = "free",
                        strip.position = "left")
  gg <- gg + ylab(NULL)
  gg
  
}
#====================================
#====================================
#====================================
#====================================
# Baseline Demand and Supply Together (aka the market, PE model, etc.)
# Here we get Pe the baseline equilibrium price before release of the alternative
interval_P <- c(P_rev_per_output_SUP[1], P_rev_per_output_SUP[length(P_rev_per_output_SUP)])
df_rL0max_SUP <- data.frame(rL0 = 1, rLmax = 0)
df_rL0max_DEM <- data.frame(rL0 = 1, rLmax = 0)
equilib_list <- get_equilibrium_values(interval_P,
                                       N_S = N_S,
                                       mu_P_fdstkCost_per_output_SUP = mu_P_fdstkCost_per_output_SUP_statQuo,
                                       cv_P_fdstkCost_per_output_SUP = cv_P_fdstkCost_per_output_SUP_statQuo,
                                       mu_P_procCost_per_output_SUP = mu_P_procCost_per_output_SUP_statQuo,
                                       cv_P_procCost_per_output_SUP = cv_P_procCost_per_output_SUP_statQuo,
                                       beta_SUP = beta_SUP_statQuo,
                                       m_yCeil_SUP = m_yCeil_SUP_statQuo,
                                       s2_yCeil_SUP = s2_yCeil_SUP_statQuo,
                                       m_A_SUP = m_A_SUP_statQuo,
                                       s2_A_SUP = s2_A_SUP_statQuo,
                                       df_rL0max_SUP = df_rL0max_SUP,
                                       chng_SUP = 1,
                                       #---
                                       P_rev_per_output_DEM = P_rev_per_output_DEM_statQuo,
                                       N_D = N_D,
                                       mu_P_fdstkCost_per_output_DEM = mu_P_fdstkCost_per_output_DEM_statQuo,
                                       cv_P_fdstkCost_per_output_DEM = cv_P_fdstkCost_per_output_DEM_statQuo,
                                       mu_P_procCost_per_output_DEM = mu_P_procCost_per_output_DEM_statQuo,
                                       cv_P_procCost_per_output_DEM = cv_P_procCost_per_output_DEM_statQuo,
                                       beta_DEM = beta_DEM_statQuo,
                                       m_yCeil_DEM = m_yCeil_DEM_statQuo,
                                       s2_yCeil_DEM = s2_yCeil_DEM_statQuo,
                                       m_A_DEM = m_A_DEM_statQuo,
                                       s2_A_DEM = s2_A_DEM_statQuo,
                                       df_rL0max_DEM = df_rL0max_DEM,
                                       chng_DEM = 1,
                                       Market0 = NULL, P_eq_00 = NULL,
                                       graph_on = T)
Tech00 <- "Before release (Baseline)"
df_Eq00 <- equilib_list[[1]]
df_Eq00$Tech <- Tech00
df_Eq00_r <- equilib_list[[2]]
df_Eq00_r$Tech <- Tech00
print(df_Eq00)
print(df_Eq00_r)
Pe00 <- df_Eq00$Pe
#------------------------------------
# df_QSQD00 <- merge(df_QS00, df_QD00, by = "Feedstock Price (lcu / MT)")
# df_QSQD00 <- df_QSQD00[, c("Feedstock Price (lcu / MT)", "Supply Market Participation", "Demand Market Participation",
#                            "Supply (MT)", "Demand (MT)")]
#colnames(df_QSQD)[4:5] <- c("Supply", "Demand")

# df_QSQD00 <- df_QSQD00 %>% gather(Type, `Quantity (MT)`, `Supply (MT)`:`Demand (MT)`)
# gg <- ggplot()
# gg <- gg + geom_line(data = df_QSQD00, aes(x = `Feedstock Price (lcu / MT)`, y = `Quantity (MT)`, color = Type, group = Type), lwd = 2)
# gg <- gg + geom_vline(xintercept = Pe00, linetype = "dashed")
# gg <- gg + theme(legend.title = element_blank())
# gg
#====================================
# Baseline market mean net revenue (yield)
# Demand side:
mu_r_DEM00 <- Pe00 / P_rev_per_output_DEM_statQuo * beta_DEM_statQuo
mu_YDe_DEM00 <- exp(m_yCeil_DEM_statQuo) * NRyd_DEM(mu_r_DEM00, Pe00, l_credit = 0)
# Supply side:
mu_r_SUP00 <- mu_P_fdstkCost_per_output_SUP_statQuo / Pe00
mu_YDe_SUP00 <- exp(m_yCeil_SUP_statQuo) * NRyd_SUP(mu_r_SUP00, Pe00, l_credit = 0)
#====================================
#====================================
#====================================
#====================================
# Create maps of independent changes in farm and factory efficiency
#------------------------------------
df_rL0max_DEM <- data.frame(rL0 = 1, rLmax = 0)
df_rL0max_SUP <- data.frame(rL0 = 1, rLmax = 0)
eta_vec <- seq(-0.4, 0.4, 0.05)
n <- length(eta_vec)
mat_Pe <- matrix(NA, n, n)
mat_Qe <- matrix(NA, n, n)
mat_muYDe_DEM <- matrix(NA, n, n)
mat_muYDe_SUP <- matrix(NA, n, n)
mat_MktParticip_DEM <- matrix(NA, n, n)
mat_MktParticip_SUP <- matrix(NA, n, n)
df_Eq_list <- list()
df_Eq_r_list <- list()
interval_P_rev_per_output_SUP <- c(P_rev_per_output_SUP[1], P_rev_per_output_SUP[length(P_rev_per_output_SUP)])
New_Tech <- "New Tech (Involuntary Adoption)"
t <- 0
for(k in 1:n){
  this_eta_DEM <- eta_vec[k]
  this_chng_DEM <- 1 + this_eta_DEM
  # mu_factry_efficiency_new <- 1 / mu_factry_efficiency_inv_statQuo * chng_DEM
  # mu_factry_efficiency_inv <- 1 / mu_factry_efficiency_new
  # sig2_factry_efficiency_inv <- (cv_factry_efficiency_inv_statQuo * mu_factry_efficiency_inv)^2
  for(l in 1:n){
    this_eta_SUP <- eta_vec[l]
    this_chng_SUP <- 1 + this_eta_SUP
    # mu_cost_per_farmProduct <- mu_cost_per_farmProduct_statQuo * chng_SUP
    # sig2_cost_per_farmProduct <- (cv_cost_per_farmProduct_statQuo * mu_cost_per_farmProduct)^2
    #---
    equilib_list <- get_equilibrium_values(interval_P_rev_per_output_SUP,
                                           N_S = N_S,
                                           mu_P_fdstkCost_per_output_SUP = mu_P_fdstkCost_per_output_SUP_statQuo,
                                           cv_P_fdstkCost_per_output_SUP = cv_P_fdstkCost_per_output_SUP_statQuo,
                                           mu_P_procCost_per_output_SUP = mu_P_procCost_per_output_SUP_statQuo,
                                           cv_P_procCost_per_output_SUP = cv_P_procCost_per_output_SUP_statQuo,
                                           beta_SUP = beta_SUP_statQuo,
                                           m_yCeil_SUP = m_yCeil_SUP_statQuo,
                                           s2_yCeil_SUP = s2_yCeil_SUP_statQuo,
                                           m_A_SUP = m_A_SUP_statQuo,
                                           s2_A_SUP = s2_A_SUP_statQuo,
                                           df_rL0max_SUP = df_rL0max_SUP,
                                           chng_SUP = this_chng_SUP,
                                           #---
                                           P_rev_per_output_DEM = P_rev_per_output_DEM_statQuo,
                                           N_D = N_D,
                                           mu_P_fdstkCost_per_output_DEM = mu_P_fdstkCost_per_output_DEM_statQuo,
                                           cv_P_fdstkCost_per_output_DEM = cv_P_fdstkCost_per_output_DEM_statQuo,
                                           mu_P_procCost_per_output_DEM = mu_P_procCost_per_output_DEM_statQuo,
                                           cv_P_procCost_per_output_DEM = cv_P_procCost_per_output_DEM_statQuo,
                                           beta_DEM = beta_DEM_statQuo,
                                           m_yCeil_DEM = m_yCeil_DEM_statQuo,
                                           s2_yCeil_DEM = s2_yCeil_DEM_statQuo,
                                           m_A_DEM = m_A_DEM_statQuo,
                                           s2_A_DEM = s2_A_DEM_statQuo,
                                           df_rL0max_DEM = df_rL0max_DEM,
                                           chng_DEM = this_chng_DEM,
                                           Market0 = NULL, P_eq_00 = NULL,
                                           graph_on = F)
    #Sys.sleep(1.5)
    df_Eq <- equilib_list[[1]]
    df_Eq$Tech <- New_Tech
    df_Eq_r <- equilib_list[[2]]
    df_Eq_r$Tech <- New_Tech
    print(df_Eq)
    print(df_Eq_r)
    #---
    t <- t + 1
    df_Eq_list[[t]] <- df_Eq
    df_Eq_r_list[[t]] <- df_Eq_r
    this_Pe <- df_Eq$Pe
    # Demand side:
    this_beta_DEM <- this_chng_DEM * beta_DEM_statQuo
    mu_r_DEM <- this_Pe / P_rev_per_output_DEM_statQuo * this_beta_DEM
    mu_YDe_DEM <- exp(m_yCeil_DEM_statQuo) * NRyd_DEM(mu_r_DEM, this_Pe, l_credit = 0)
    # Supply side:
    this_mu_P_fdstkCost_per_output_SUP <- this_chng_SUP * mu_P_fdstkCost_per_output_SUP_statQuo
    mu_r_SUP <- this_mu_P_fdstkCost_per_output_SUP / df_Eq$Pe
    mu_YDe_SUP <- exp(m_yCeil_SUP_statQuo) * NRyd_SUP(mu_r_SUP, this_Pe, l_credit = 0)
    
    mat_Pe[k, l] <- df_Eq$Pe
    mat_Qe[k, l] <- df_Eq$Qe
    mat_muYDe_SUP[k, l] <- mu_YDe_SUP
    mat_muYDe_DEM[k, l] <- mu_YDe_DEM
    mat_MktParticip_DEM[k, l] <- df_Eq$mkt_particip_DEM
    mat_MktParticip_SUP[k, l] <- df_Eq$mkt_particip_SUP
    
    print(c(k = k, l = l))
  }
}
df_Eq <- do.call(rbind, df_Eq_list)

# Maps
#------------------------------------
xtick_labs <- 1 / beta_DEM_statQuo * (1 + eta_vec)
ytick_labs <- mu_P_fdstkCost_per_output_SUP_statQuo * (1 + eta_vec)
mapPalette <- colorRampPalette(c("magenta", "cyan"))
mapPalette_inv <- colorRampPalette(c("cyan", "magenta"))
#---
inMat <- mat_Pe
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette_inv(45), method = "edge")
title(main = "Equilibrium Price Map (lcu)", cex.main = 1)

inMat <- mat_Qe
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Equilibrium Quantity Map (MT / day)", cex.main = 1)

inMat <- mat_muYDe_SUP
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Mean Farm Net Revenue Map (lcu / ha.)", cex.main = 1)

inMat <- mat_muYDe_DEM
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Mean Factory Net Revenue Map (lcu / day)", cex.main = 1)

inMat <- mat_MktParticip_DEM
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Demand Market Participation Map", cex.main = 1)

inMat <- mat_MktParticip_SUP
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Supply Market Participation Map", cex.main = 1)
#====================================
#====================================
#====================================
#====================================
#====================================
#====================================
#====================================
#====================================
#====================================
#====================================
#====================================
#====================================
#====================================
# Now same market but with release of alternative tech
rvec <- seq(0, 1, 0.001)
interval_r <- c(rvec[1], rvec[length(rvec)])
P_eq_00 <- Pe00
eta_vec <- round(seq(-0.4, 0.4, 0.1), 2)
interval_P_rev_per_output_SUP <- c(P_rev_per_output_SUP[1], P_rev_per_output_SUP[length(P_rev_per_output_SUP)])
df_rL0max_DEM <- data.frame(rL0 = NULL, rLmax = NULL)
df_rL0max_SUP <- data.frame(rL0 = NULL, rLmax = NULL)
#====================================
n <- length(eta_vec)
mat_muYDe_DEM0 <- matrix(NA, n, n)
mat_muYDe_SUP0 <- matrix(NA, n, n)
mat_muYDe_DEM1 <- matrix(NA, n, n)
mat_muYDe_SUP1 <- matrix(NA, n, n)
mat_MktParticip_DEM0 <- matrix(NA, n, n)
mat_MktParticip_SUP0 <- matrix(NA, n, n)
mat_MktParticip_DEM1 <- matrix(NA, n, n)
mat_MktParticip_SUP1 <- matrix(NA, n, n)
mat_Pe1 <- matrix(NA, n, n)
mat_Qe1 <- matrix(NA, n, n)
mat_Pe0 <- matrix(NA, n, n)
mat_Qe0 <- matrix(NA, n, n)
mat_Adopt_DEM1 <- matrix(NA, n, n)
mat_Adopt_SUP1 <- matrix(NA, n, n)
df_Eq0_list <- list()
df_Eq0r_list <- list()
df_Eq1_list <- list()
df_Eq1r_list <- list()
#====================================
#====================================
#====================================
# Get roots, adoption cutoff r values for each alternative price
#====================================
graph_on <- F
for(k in 1:n){
  this_eta_DEM <- eta_vec[k]
  this_chng_DEM <- 1 + this_eta_DEM
  #graphs
  #-------------------------------
  if(graph_on){
    factry_efficiency_new <- 1 / beta_DEM_statQuo * this_chng_DEM
    beta_DEM_new <- 1 / factry_efficiency_new
    P0 <- P_eq_00
    #out_df <- get_rL0Lmax_01_DEM(P_rev_per_output_SUP, P0, interval_r, chng_DEM)
    df_r01_L0max_DEM <- get_r01_L0max_DEM(P_rev_per_output_SUP, P0, interval_r, this_chng_DEM)
    df_rL0max_DEM0_graph <- df_r01_L0max_DEM[, c(1, 2)]
    colnames(df_rL0max_DEM0_graph) <- c("rL0", "rLmax")
    df_rL0max_DEM1_graph <- df_r01_L0max_DEM[, c(3, 4)]
    colnames(df_rL0max_DEM1_graph) <- c("rL0", "rLmax")
    #---
    df_QD0 <- Q_DorS(N = N_D,
                     P_rev_per_output = P_rev_per_output_DEM_statQuo,
                     mu_P_fdstkCost_per_output = P_rev_per_output_SUP,
                     mu_P_procCost_per_output = mu_P_procCost_per_output_DEM_statQuo,
                     cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM_statQuo,
                     cv_P_procCost_per_output = cv_P_procCost_per_output_DEM_statQuo,
                     beta = beta_DEM_statQuo,
                     m_yCeil = m_yCeil_DEM_statQuo,
                     s2_yCeil = s2_yCeil_DEM_statQuo,
                     m_A = m_A_DEM_statQuo,
                     s2_A = s2_A_DEM_statQuo,
                     df_rL0max = df_rL0max_DEM0_graph,
                     l_credit = 0)
    colnames(df_QD0) <- c("Demand (MT)", "Demand Market Participation")
    df_QD0$`Root Price (lcu / MT)` <- P_rev_per_output_SUP
    #---
    df_QD1 <- Q_DorS(N = N_D,
                     P_rev_per_output = P_rev_per_output_DEM_statQuo,
                     mu_P_fdstkCost_per_output = P_rev_per_output_SUP,
                     mu_P_procCost_per_output = mu_P_procCost_per_output_DEM_statQuo,
                     cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM_statQuo,
                     cv_P_procCost_per_output = cv_P_procCost_per_output_DEM_statQuo,
                     beta = beta_DEM_new,
                     m_yCeil = m_yCeil_DEM_statQuo,
                     s2_yCeil = s2_yCeil_DEM_statQuo,
                     m_A = m_A_DEM_statQuo,
                     s2_A = s2_A_DEM_statQuo,
                     df_rL0max = df_rL0max_DEM1_graph,
                     l_credit = 0)
    colnames(df_QD1) <- c("Demand (MT)", "Demand Market Participation")
    df_QD1$`Root Price (lcu / MT)` <- P_rev_per_output_SUP
    
    df_QD1$Type <- "Alternative"
    df_QD0$Type <- "Baseline"
    df_QD00$Type <- "Before release"
    df_QD01comp <- df_QD1
    df_QD01comp$`Demand (MT)` <- df_QD0$`Demand (MT)` + df_QD1$`Demand (MT)`
    df_QD01comp$`Demand Market Participation` <- df_QD0$`Demand Market Participation` + df_QD1$`Demand Market Participation`
    df_QD01comp$Type <- "After release\n(alt + base tech)"
    df_plot <- rbind(df_QD1, df_QD0)
    #df_plot <- rbind(df_plot, df_QD00)
    #df_plot <- rbind(df_plot, df_QD01comp)
    gathercols <- colnames(df_plot)[1:2]
    df_plot <- df_plot %>% gather_("Graph", "Value", gathercols)
    
    #--
    df_temp1 <- subset(df_plot, Graph == "Demand (MT)")
    u <- df_temp1$Value
    df_temp1$Value[which(u < 1)] <- NA
    ind_na <- which(is.na(df_temp1$Value))
    df_temp2 <- subset(df_plot, Graph == "Demand Market Participation")
    df_temp2$Value[ind_na] <- NA
    df_plot <- rbind(df_temp1, df_temp2)
    #--
    AdoptRate <- df_QD1$`Demand Market Participation` / (df_QD1$`Demand Market Participation` + df_QD0$`Demand Market Participation`)
    n_bins <- length(P_rev_per_output_SUP)
    df_plotAR <- data.frame(xmin = P_rev_per_output_SUP[-n_bins], xmax = P_rev_per_output_SUP[-1])
    df_plotAR$`Adoption\nRate` <- AdoptRate[-1]
    u <- df_QD0$`Demand (MT)`
    ind <- which(u > 0)
    P_adoptRange_start <- df_QD0$`Root Price (lcu / MT)`[ind[1]]
    P_adoptRange_stop <- df_QD0$`Root Price (lcu / MT)`[ind[length(ind)]]
    P_adoptRange <- c(P_adoptRange_start, P_adoptRange_stop)
    #---
    # Demand curves AND mkt particip curves together using facet_wrap
    gg <- ggplot()
    gg <- gg + geom_rect(data = df_plotAR, aes(xmin = xmin, xmax = xmax,
                                               ymin = -Inf, ymax = Inf, fill = `Adoption\nRate`), alpha = 0.4)
    gg <- gg + scale_fill_gradient2(low = "orange", mid = "white", high = "#9999CC",
                                    midpoint = 0.5)
    gg <- gg + geom_line(data = df_plot, aes(x = `Root Price (lcu / MT)`, y = Value,
                                             group = Type, color = Type), lwd = 2)
    gg <- gg + scale_color_manual(values=c("#9999CC", "orange"))
    gg <- gg + geom_vline(xintercept = P_adoptRange, linetype = "dashed")
    gg <- gg + facet_wrap(~Graph, ncol = 1, scales = "free",
                          strip.position = "left")
    gg <- gg + ylab(NULL)
    #gg <- gg + theme(legend.title = element_blank())
    gg <- gg + theme_bw()
    #gg <- gg + coord_cartesian(xlim = c(P_adoptRange_start * 0.85, P_adoptRange_stop * 1.15))
    gg
    #---
    # Composite curve vs. before release curve
    df_plot <- rbind(df_QD01comp, df_QD00)
    df_plot <- df_plot %>% gather_("Graph", "Value", gathercols)
    u <- df_plot$Value
    df_plot$Value[which(u == 0)] <- NA
    
    gg <- ggplot()
    gg <- gg + geom_rect(data = df_plotAR, aes(xmin = xmin, xmax = xmax,
                                               ymin = -Inf, ymax = Inf, fill = `Adoption\nRate`), alpha = 0.4)
    gg <- gg + scale_fill_gradient2(low = "orange", mid = "white", high = "#9999CC",
                                    midpoint = 0.5)
    gg <- gg + geom_line(data = df_plot, aes(x = `Root Price (lcu / MT)`, y = Value,
                                             group = Type, color = Type), lwd = 2)
    gg <- gg + scale_color_manual(values=c("orange", "#9999CC"))
    gg <- gg + geom_vline(xintercept = P_adoptRange, linetype = "dashed")
    gg <- gg + facet_wrap(~Graph, ncol = 1, scales = "free",
                          strip.position = "left")
    gg <- gg + ylab(NULL)
    #gg <- gg + theme(legend.title = element_blank())
    gg <- gg + theme_bw()
    #gg <- gg + coord_cartesian(xlim = c(P_adoptRange_start * 0.85, P_adoptRange_stop * 1.15))
    gg
    #---
    # Mkt participation vs. adoption rate
    df_plot1 <- data.frame(df_QD01comp$`Root Price (lcu / MT)`, df_QD01comp$`Demand Market Participation`, AdoptRate)
    colnames(df_plot1) <- c("Root Price\n(lcu / MT)", "Demand Mkt\nParticipation", "Adoption\nRate")
    df_plot <- subset(df_plot1, `Root Price\n(lcu / MT)` > P_adoptRange[1] & `Root Price\n(lcu / MT)` < P_adoptRange[2])
    gg <- ggplot(df_plot, aes(x = `Adoption\nRate`, y = `Demand Mkt\nParticipation`, color = `Root Price\n(lcu / MT)`))
    gg <- gg + geom_line(lwd = 2)
    gg <- gg + theme_bw()
    gg
    df_plot <- df_plot1 %>% gather(Type, Value, `Demand Mkt\nParticipation`:`Adoption\nRate`)
    gg <- ggplot(df_plot, aes(x = `Root Price\n(lcu / MT)`, y = Value,
                              group = Type, color = Type))
    gg <- gg + scale_color_manual(values = c("magenta", "blue"))
    gg <- gg + geom_line(lwd = 2)
    gg <- gg + geom_vline(xintercept = P_adoptRange, linetype = "dashed")
    gg <- gg + ylab(NULL)
    gg <- gg + theme_bw()
    gg <- gg + theme(legend.title = element_blank())
    gg <- gg + coord_cartesian(xlim = c(P_adoptRange_start * 0.85, P_adoptRange_stop))
    gg
  }
  #-------------------------------
  
  for(l in 1:n){
    this_eta_SUP <- eta_vec[l]
    this_chng_SUP <- 1 + this_eta_SUP
    #graphs
    #-------------------------------
    if(graph_on){
      #graphing
      mu_P_fdstkCost_per_output_SUP_new <- mu_P_fdstkCost_per_output_SUP_statQuo * this_chng_SUP
      P0 <- P_eq_00
      #out_df <- get_rL0Lmax_01_DEM(P_rev_per_output_SUP, P0, interval_r, chng_DEM)
      df_r01_L0max_SUP <- get_r01_L0max_SUP(P_rev_per_output_SUP, P0, interval_r, this_chng_SUP)
      df_rL0max_SUP0_graph <- df_r01_L0max_SUP[, c(1, 2)]
      colnames(df_rL0max_SUP0_graph) <- c("rL0", "rLmax")
      df_rL0max_SUP1_graph <- df_r01_L0max_SUP[, c(3, 4)]
      colnames(df_rL0max_SUP1_graph) <- c("rL0", "rLmax")
      #---
      df_QS0 <- Q_DorS(N = N_S,
                       P_rev_per_output = P_rev_per_output_SUP,
                       mu_P_fdstkCost_per_output = mu_P_fdstkCost_per_output_SUP_statQuo,
                       mu_P_procCost_per_output = mu_P_procCost_per_output_SUP_statQuo,
                       cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_SUP_statQuo,
                       cv_P_procCost_per_output = cv_P_procCost_per_output_SUP_statQuo,
                       beta = beta_SUP_statQuo,
                       m_yCeil = m_yCeil_SUP_statQuo,
                       s2_yCeil = s2_yCeil_SUP_statQuo,
                       m_A = m_A_SUP_statQuo,
                       s2_A = s2_A_SUP_statQuo,
                       df_rL0max = df_rL0max_SUP0_graph,
                       l_credit = 0)
      colnames(df_QS0) <- c("Supply (MT)", "Supply Market Participation")
      df_QS0$`Root Price (lcu / MT)` <- P_rev_per_output_SUP
      #---
      df_QS1 <- Q_DorS(N = N_S,
                       P_rev_per_output = P_rev_per_output_SUP,
                       mu_P_fdstkCost_per_output = mu_P_fdstkCost_per_output_SUP_new,
                       mu_P_procCost_per_output = mu_P_procCost_per_output_SUP_statQuo,
                       cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_SUP_statQuo,
                       cv_P_procCost_per_output = cv_P_procCost_per_output_SUP_statQuo,
                       beta = beta_SUP_statQuo,
                       m_yCeil = m_yCeil_SUP_statQuo,
                       s2_yCeil = s2_yCeil_SUP_statQuo,
                       m_A = m_A_SUP_statQuo,
                       s2_A = s2_A_SUP_statQuo,
                       df_rL0max = df_rL0max_SUP1_graph,
                       l_credit = 0)
      colnames(df_QS1) <- c("Supply (MT)", "Supply Market Participation")
      df_QS1$`Root Price (lcu / MT)` <- P_rev_per_output_SUP
      u <- df_QS1$`Supply (MT)`
      #---
      df_QS1$Type <- "Alternative"
      df_QS0$Type <- "Baseline"
      df_QS00$Type <- "Before release"
      df_QS01comp <- df_QS1
      df_QS01comp$`Supply (MT)` <- df_QS0$`Supply (MT)` + df_QS1$`Supply (MT)`
      df_QS01comp$`Supply Market Participation` <- df_QS0$`Supply Market Participation` + df_QS1$`Supply Market Participation`
      df_QS01comp$Type <- "Composite\n(alt + base tech)"
      df_plot <- rbind(df_QS1, df_QS0)
      #df_plot <- rbind(df_plot, df_QS00)
      #df_plot <- rbind(df_plot, df_QS01comp)
      gathercols <- colnames(df_plot)[1:2]
      df_plot <- df_plot %>% gather_("Graph", "Value", gathercols)
      #--
      df_temp1 <- subset(df_plot, Graph == "Supply (MT)")
      u <- df_temp1$Value
      df_temp1$Value[which(u < 1)] <- NA
      ind_na <- which(is.na(df_temp1$Value))
      df_temp2 <- subset(df_plot, Graph == "Supply Market Participation")
      df_temp2$Value[ind_na] <- NA
      df_plot <- rbind(df_temp1, df_temp2)
      #--
      AdoptRate <- df_QS1$`Supply Market Participation` / (df_QS1$`Supply Market Participation` + df_QS0$`Supply Market Participation`)
      n_bins <- length(P_rev_per_output_SUP)
      df_plotAR <- data.frame(xmin = P_rev_per_output_SUP[-n_bins], xmax = P_rev_per_output_SUP[-1])
      df_plotAR$`Adoption\nRate` <- AdoptRate[-1]
      u <- df_QS1$`Supply (MT)`
      P_adoptRange_start <- df_QS1$`Root Price (lcu / MT)`[which(u > 0)][1]
      u <- df_QS0$`Supply (MT)`
      ind <- which(u > 1)
      P_adoptRange_stop <- df_QS0$`Root Price (lcu / MT)`[ind[length(ind)]]
      P_adoptRange <- c(P_adoptRange_start, P_adoptRange_stop)
      #---
      # Supply curves AND mkt particip curves together using facet_wrap
      gg <- ggplot()
      gg <- gg + geom_rect(data = df_plotAR, aes(xmin = xmin, xmax = xmax,
                                                   ymin = -Inf, ymax = Inf, fill = `Adoption\nRate`), alpha = 0.4)
      gg <- gg + scale_fill_gradient2(low = "orange", mid = "white", high = "#9999CC",
                                      midpoint = 0.5)
      gg <- gg + geom_line(data = df_plot, aes(x = `Root Price (lcu / MT)`, y = Value,
                                               group = Type, color = Type), lwd = 2)
      gg <- gg + scale_color_manual(values=c("#9999CC", "orange"))
      gg <- gg + geom_vline(xintercept = P_adoptRange, linetype = "dashed")
      gg <- gg + facet_wrap(~Graph, ncol = 1, scales = "free",
                            strip.position = "left")
      gg <- gg + ylab(NULL)
      #gg <- gg + theme(legend.title = element_blank())
      gg <- gg + theme_bw()
      gg <- gg + coord_cartesian(xlim = c(P_adoptRange_start * 0.85, P_adoptRange_stop * 1.15))
      gg
      #---
      # Composite curve vs. before release curve
      df_plot <- rbind(df_QS01comp, df_QS00)
      df_plot <- df_plot %>% gather_("Graph", "Value", gathercols)
      u <- df_plot$Value
      df_plot$Value[which(u == 0)] <- NA
      
      gg <- ggplot()
      gg <- gg + geom_rect(data = df_plotAR, aes(xmin = xmin, xmax = xmax,
                                                 ymin = -Inf, ymax = Inf, fill = `Adoption\nRate`), alpha = 0.4)
      gg <- gg + scale_fill_gradient2(low = "orange", mid = "white", high = "#9999CC",
                                      midpoint = 0.5)
      gg <- gg + geom_line(data = df_plot, aes(x = `Root Price (lcu / MT)`, y = Value,
                                               group = Type, color = Type), lwd = 2)
      gg <- gg + scale_color_manual(values=c("orange", "#9999CC"))
      gg <- gg + geom_vline(xintercept = P_adoptRange, linetype = "dashed")
      gg <- gg + facet_wrap(~Graph, ncol = 1, scales = "free",
                            strip.position = "left")
      gg <- gg + ylab(NULL)
      #gg <- gg + theme(legend.title = element_blank())
      gg <- gg + theme_bw()
      gg <- gg + coord_cartesian(xlim = c(P_adoptRange_start * 0.85, P_adoptRange_stop * 1.15))
      gg
      #---
      # Mkt participation vs. adoption rate
      df_plot1 <- data.frame(df_QS01comp$`Root Price (lcu / MT)`, df_QS01comp$`Supply Market Participation`, AdoptRate)
      colnames(df_plot1) <- c("Root Price\n(lcu / MT)", "Supply Mkt\nParticipation", "Adoption\nRate")
      df_plot <- subset(df_plot1, `Root Price\n(lcu / MT)` > P_adoptRange[1] & `Root Price\n(lcu / MT)` < P_adoptRange[2])
      gg <- ggplot(df_plot, aes(x = `Adoption\nRate`, y = `Supply Mkt\nParticipation`, color = `Root Price\n(lcu / MT)`))
      gg <- gg + geom_line(lwd = 2)
      gg <- gg + theme_bw()
      gg
      df_plot <- df_plot1 %>% gather(Type, Value, `Supply Mkt\nParticipation`:`Adoption\nRate`)
      gg <- ggplot(df_plot, aes(x = `Root Price\n(lcu / MT)`, y = Value,
                                group = Type, color = Type))
      gg <- gg + scale_color_manual(values = c("magenta", "blue"))
      gg <- gg + geom_line(lwd = 2)
      gg <- gg + geom_vline(xintercept = P_adoptRange, linetype = "dashed")
      gg <- gg + ylab(NULL)
      gg <- gg + theme_bw()
      gg <- gg + theme(legend.title = element_blank())
      gg <- gg + coord_cartesian(xlim = c(P_adoptRange_start * 0.85, P_adoptRange_stop * 1.15))
      gg
      
      
    }
    #-------------------------------
    
    #---
    Market0 <- T
    #interval_P_rev_per_output_SUP <- c(P_rev_per_output_SUP[1], P_rev_per_output_SUP[length(P_rev_per_output_SUP)])
    df_rL0max_DEM <- NULL
    df_rL0max_SUP <- NULL
    
    equilib_list <- get_equilibrium_values(interval_P_rev_per_output_SUP,
                                           N_S = N_S,
                                           mu_P_fdstkCost_per_output_SUP = mu_P_fdstkCost_per_output_SUP_statQuo,
                                           cv_P_fdstkCost_per_output_SUP = cv_P_fdstkCost_per_output_SUP_statQuo,
                                           mu_P_procCost_per_output_SUP = mu_P_procCost_per_output_SUP_statQuo,
                                           cv_P_procCost_per_output_SUP = cv_P_procCost_per_output_SUP_statQuo,
                                           beta_SUP = beta_SUP_statQuo,
                                           m_yCeil_SUP = m_yCeil_SUP_statQuo,
                                           s2_yCeil_SUP = s2_yCeil_SUP_statQuo,
                                           m_A_SUP = m_A_SUP_statQuo,
                                           s2_A_SUP = s2_A_SUP_statQuo,
                                           df_rL0max_SUP = df_rL0max_SUP,
                                           chng_SUP = this_chng_SUP,
                                           #---
                                           P_rev_per_output_DEM = P_rev_per_output_DEM_statQuo,
                                           N_D = N_D,
                                           mu_P_fdstkCost_per_output_DEM = mu_P_fdstkCost_per_output_DEM_statQuo,
                                           cv_P_fdstkCost_per_output_DEM = cv_P_fdstkCost_per_output_DEM_statQuo,
                                           mu_P_procCost_per_output_DEM = mu_P_procCost_per_output_DEM_statQuo,
                                           cv_P_procCost_per_output_DEM = cv_P_procCost_per_output_DEM_statQuo,
                                           beta_DEM = beta_DEM_statQuo,
                                           m_yCeil_DEM = m_yCeil_DEM_statQuo,
                                           s2_yCeil_DEM = s2_yCeil_DEM_statQuo,
                                           m_A_DEM = m_A_DEM_statQuo,
                                           s2_A_DEM = s2_A_DEM_statQuo,
                                           df_rL0max_DEM = df_rL0max_DEM,
                                           chng_DEM = this_chng_DEM,
                                           Market0, P_eq_00 = Pe00,
                                           graph_on = T)
    df_Eq0 <- equilib_list[[1]]
    df_Eq0_r <- equilib_list[[2]]
    #print(df_Eq0)
    #print(df_Eq0_r)
    
    if(is.null(df_Eq0)){
      MktParticip_DEM0 <- 0
      MktParticip_SUP0 <- 0
      mat_Pe0[k, l] <- NA
      mat_Qe0[k, l] <- NA
      mat_MktParticip_DEM0[k, l] <- MktParticip_DEM0
      mat_MktParticip_SUP0[k, l] <- MktParticip_SUP0
      mat_muYDe_SUP0[k, l] <- NA
      mat_muYDe_DEM0[k, l] <- NA
    }else{
      if(nrow(df_Eq0) > 1){
        ind_keep <- which.max(df_Eq0$Pe)
        #ind_keep <- df_Eq0$Pe[2]
        df_Eq0 <- df_Eq0[ind_keep, ]
      }
      Pe0 <- df_Eq0$Pe
      # Demand side:
      this_beta_DEM <- this_chng_DEM * beta_DEM_statQuo
      mu_r_DEM0 <- Pe0 / P_rev_per_output_DEM_statQuo * this_beta_DEM
      mu_YDe_DEM0 <- exp(m_yCeil_DEM_statQuo) * NRyd_DEM(mu_r_DEM0, Pe0, l_credit = 0)
      # Supply side:
      this_mu_P_fdstkCost_per_output_SUP <- this_chng_SUP * mu_P_fdstkCost_per_output_SUP_statQuo
      mu_r_SUP0 <- this_mu_P_fdstkCost_per_output_SUP / Pe0
      mu_YDe_SUP0 <- exp(m_yCeil_SUP_statQuo) * NRyd_SUP(mu_r_SUP0, Pe0, l_credit = 0)
      #---
      MktParticip_DEM0 <- df_Eq0$mkt_particip_DEM
      MktParticip_SUP0 <- df_Eq0$mkt_particip_SUP
      #---
      mat_Pe0[k, l] <- Pe0
      mat_Qe0[k, l] <- df_Eq0$Qe
      mat_MktParticip_DEM0[k, l] <- df_Eq0$mkt_particip_DEM
      mat_MktParticip_SUP0[k, l] <- df_Eq0$mkt_particip_SUP
      mat_muYDe_SUP0[k, l] <- mu_YDe_SUP0
      mat_muYDe_DEM0[k, l] <- mu_YDe_DEM0
      #---
    }
    
    #---
    Market0 <- F
    equilib_list <- get_equilibrium_values(interval_P_rev_per_output_SUP,
                                           N_S = N_S,
                                           mu_P_fdstkCost_per_output_SUP = mu_P_fdstkCost_per_output_SUP_statQuo,
                                           cv_P_fdstkCost_per_output_SUP = cv_P_fdstkCost_per_output_SUP_statQuo,
                                           mu_P_procCost_per_output_SUP = mu_P_procCost_per_output_SUP_statQuo,
                                           cv_P_procCost_per_output_SUP = cv_P_procCost_per_output_SUP_statQuo,
                                           beta_SUP = beta_SUP_statQuo,
                                           m_yCeil_SUP = m_yCeil_SUP_statQuo,
                                           s2_yCeil_SUP = s2_yCeil_SUP_statQuo,
                                           m_A_SUP = m_A_SUP_statQuo,
                                           s2_A_SUP = s2_A_SUP_statQuo,
                                           df_rL0max_SUP = df_rL0max_SUP,
                                           chng_SUP = this_chng_SUP,
                                           #---
                                           P_rev_per_output_DEM = P_rev_per_output_DEM_statQuo,
                                           N_D = N_D,
                                           mu_P_fdstkCost_per_output_DEM = mu_P_fdstkCost_per_output_DEM_statQuo,
                                           cv_P_fdstkCost_per_output_DEM = cv_P_fdstkCost_per_output_DEM_statQuo,
                                           mu_P_procCost_per_output_DEM = mu_P_procCost_per_output_DEM_statQuo,
                                           cv_P_procCost_per_output_DEM = cv_P_procCost_per_output_DEM_statQuo,
                                           beta_DEM = beta_DEM_statQuo,
                                           m_yCeil_DEM = m_yCeil_DEM_statQuo,
                                           s2_yCeil_DEM = s2_yCeil_DEM_statQuo,
                                           m_A_DEM = m_A_DEM_statQuo,
                                           s2_A_DEM = s2_A_DEM_statQuo,
                                           df_rL0max_DEM = df_rL0max_DEM,
                                           chng_DEM = this_chng_DEM,
                                           Market0, P_eq_00 = Pe00,
                                           graph_on = T)
    df_Eq1 <- equilib_list[[1]]
    df_Eq1_r <- equilib_list[[2]]
    #print(df_Eq1_r)
    if(is.null(df_Eq1)){
      MktParticip_DEM1 <- 0
      MktParticip_SUP1 <- 0
      mat_Pe1[k, l] <- NA
      mat_Qe1[k, l] <- NA
      mat_MktParticip_DEM1[k, l] <- MktParticip_DEM1
      mat_MktParticip_SUP1[k, l] <- MktParticip_SUP1
      mat_muYDe_SUP1[k, l] <- NA
      mat_muYDe_DEM1[k, l] <- NA
      
    }else{
      if(nrow(df_Eq1) > 1){
        ind_keep <- which.max(df_Eq1$Pe)
        #ind_keep <- df_Eq1$Pe[2]
        df_Eq1 <- df_Eq1[ind_keep, ]
      }
      Pe1 <- df_Eq1$Pe
      # Demand side:
      this_beta_DEM <- this_chng_DEM * beta_DEM_statQuo
      mu_r_DEM1 <- Pe1 / P_rev_per_output_DEM_statQuo * this_beta_DEM
      mu_YDe_DEM1 <- exp(m_yCeil_DEM_statQuo) * NRyd_DEM(mu_r_DEM1, Pe1, l_credit = 1)
      # Supply side:
      this_mu_P_fdstkCost_per_output_SUP <- this_chng_SUP * mu_P_fdstkCost_per_output_SUP_statQuo
      mu_r_SUP1 <- this_mu_P_fdstkCost_per_output_SUP / Pe1
      mu_YDe_SUP1 <- exp(m_yCeil_SUP_statQuo) * NRyd_SUP(mu_r_SUP1, Pe1, l_credit = 1)
      #---
      MktParticip_DEM1 <- df_Eq1$mkt_particip_DEM
      MktParticip_SUP1 <- df_Eq1$mkt_particip_SUP
      #---
      mat_Pe1[k, l] <- Pe1
      mat_Qe1[k, l] <- df_Eq1$Qe
      mat_MktParticip_DEM1[k, l] <- df_Eq1$mkt_particip_DEM
      mat_MktParticip_SUP1[k, l] <- df_Eq1$mkt_particip_SUP
      mat_muYDe_SUP1[k, l] <- mu_YDe_SUP1
      mat_muYDe_DEM1[k, l] <- mu_YDe_DEM1
    }
    Adopt_DEM1 <- MktParticip_DEM1 / (MktParticip_DEM1 + MktParticip_DEM0)
    Adopt_SUP1 <- MktParticip_SUP1 / (MktParticip_SUP1 + MktParticip_SUP0)
    Adopt_DEM1 <- ifelse(is.nan(Adopt_DEM1), NA, Adopt_DEM1)
    Adopt_SUP1 <- ifelse(is.nan(Adopt_SUP1), NA, Adopt_SUP1)
    # Adopt_DEM0 <- 1 - Adopt_DEM1
    # Adopt_SUP0 <- 1 - Adopt_SUP1
    mat_Adopt_DEM1[k, l] <- Adopt_DEM1
    mat_Adopt_SUP1[k, l] <- Adopt_SUP1
    #---
    Adopt_SUP1
    print(c(k = k, l = l))
  }
}




#-----------------
xtick_labs <- 1 / beta_DEM_statQuo * (1 + eta_vec)
ytick_labs <- mu_P_fdstkCost_per_output_SUP_statQuo * (1 + eta_vec)
mapPalette <- colorRampPalette(c("magenta", "cyan"))
mapPalette_inv <- colorRampPalette(c("cyan", "magenta"))
#-----------------

inMat <- mat_Pe1
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", levels = seq(1000, 3500, 250), labcex = 1, col = mapPalette_inv(45), method = "edge")
title(main = "Alternative Market Equilibrium Price Map (lcu / MT)", cex.main = 1)

inMat <- mat_Qe1
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Alternative Market Equilibrium Quantity Map (MT / day)", cex.main = 1)

inMat <- mat_Pe0
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", levels = seq(1000, 3500, 250), labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Baseline Market Equilibrium Price Map (lcu / MT)", cex.main = 1)

inMat <- mat_Qe0
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Baseline Market Equilibrium Quantity Map (MT / day)", cex.main = 1)


inMat <- mat_Adopt_SUP1
# inMat[which(inMat == 0)] <- NA
# inMat[which(inMat == 1)] <- NA
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "I",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Supply Side Adoption Rate Map", cex.main = 1)

inMat <- mat_Adopt_DEM1
# inMat[which(inMat == 0)] <- NA
# inMat[which(inMat == 1)] <- NA
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Demand Side Adoption Rate Map", cex.main = 1)




inMat <- mat_MktParticip_DEM0
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Baseline Demand Market Participation Map", cex.main = 1)


inMat <- mat_MktParticip_DEM1
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Alternative Demand Market Participation Map", cex.main = 1)


inMat <- mat_MktParticip_SUP0
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Baseline Supply Market Participation Map", cex.main = 1)


inMat <- mat_MktParticip_SUP1
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Alternative Supply Market Participation Map", cex.main = 1)


inMat <- mat_muYDe_DEM0
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Baseline Mean Factory Net Revenue Map (lcu / day)", cex.main = 1)

inMat <- mat_muYDe_SUP0
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Baseline Mean Supply Net Revenue Map (lcu / ha.)", cex.main = 1)


inMat <- mat_muYDe_DEM1
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Alternative Mean Factory Net Revenue Map (lcu / day)", cex.main = 1)

inMat <- mat_muYDe_SUP1
surface <- list(x = xtick_labs,
                y = ytick_labs,
                z = inMat)
plotSurface2(surface, type = "C",
             xlab = "Mean factory efficiency (kL Ethanol / MT Root)",
             ylab = "Mean farm cost (lcu / MT Root)", labcex = 1, col = mapPalette(45), method = "edge")
title(main = "Alternative Mean Supply Net Revenue Map (lcu / ha.)", cex.main = 1)



#========================================
# Supply participation plots
N = N_S
P_rev_per_output = Pe00
mu_P_fdstkCost_per_output = mu_P_fdstkCost_per_output_SUP_statQuo
mu_P_procCost_per_output = mu_P_procCost_per_output_SUP_statQuo
cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_SUP_statQuo
cv_P_procCost_per_output = cv_P_procCost_per_output_SUP_statQuo
beta = beta_SUP_statQuo
m_yCeil = m_yCeil_SUP_statQuo
s2_yCeil = s2_yCeil_SUP_statQuo
m_A = m_A_SUP_statQuo
s2_A = s2_A_SUP_statQuo
df_rL0max
l_credit = 0
#--------------------------------
# mu_r
ratio_price <- (mu_P_fdstkCost_per_output + mu_P_procCost_per_output) / P_rev_per_output
mu_r <- ratio_price * beta * (1 - l_credit)
#--------------------------------
# sig2_r
sig2_fdstkCost_per_output <- (mu_P_fdstkCost_per_output * cv_P_fdstkCost_per_output)^2
sig2_procCost_per_output <- (mu_P_procCost_per_output * cv_P_procCost_per_output)^2
sig2_r <- (sig2_fdstkCost_per_output + sig2_procCost_per_output) * (beta / P_rev_per_output)^2
#--------------------------------
# s_qStar
s2_qStar <- s2_A + s2_yCeil + sig2_r
s_qStar <- sqrt(s2_qStar)
#--------------------------------
# mu_qStar
m_qStar <- m_A + m_yCeil - mu_r
mu_qStar <- exp(m_qStar + s2_qStar / 2)
#--------------------------------
# Nvr0, Nvr1
# Note: if sig2_beta = 0 then so should s2_yCeil, and N_D should = 1
if(cv_P_fdstkCost_per_output != 0 | cv_P_procCost_per_output != 0){
  rL0 <- df_rL0max$rL0
  rLmax <- df_rL0max$rLmax
  vrLmax <- (-rLmax + mu_r - s2_qStar) / s_qStar
  vrL0 <- (-rL0 + mu_r - s2_qStar) / s_qStar
  NvrLmax <- pnorm(vrLmax)
  NvrL0 <- pnorm(vrL0)
  #--------------------------------
  # QD or QS
  #mkt_participation <- (1 + NvrLmax - NvrL0) / 2
  mkt_participation <- NvrLmax - NvrL0
  Q_D_or_S <- N * mu_qStar * mkt_participation
}else{
  Q_D_or_S <- mu_qStar
}
#--------------------------------
if(nrow(df_rL0max) > 1){
  # ind1 <- which(df_rL0max$rL0 == 0)
  # ind2 <- which(df_rL0max$rLmax == 0)
  # ind0 <- intersect(ind1, ind2)
  # Q_D_or_S[ind0] <- 0
  # mkt_participation[ind0] <- NA
}else{
  if(rL0 == 0 & rLmax == 0){
    Q_D_or_S <- 0
    mkt_participation <- NA
  }
}
#--------------------------------
df_out <- data.frame(Q_D_or_S, mkt_participation)
#--------------------------------
y <- seq(-3, 3, 0.1)
df_y <- data.frame(y = y, f = dnorm(y))
df_y <- df_y %>% mutate(area = ifelse(y > vrL0 & y < vrLmax,
                                      "Participating", "Not Participating"))
gg <- ggplot(data = df_y, aes(x = y, ymin = 0, ymax = f))
gg <- gg + geom_ribbon(aes(fill = factor("Not participating")))
gg <- gg + geom_ribbon(data = df_y[df_y$area == "Participating", ], aes(fill = area))
#gg <- gg + geom_ribbon(data = df_y[df_y$area == "Switch", ], aes(fill = area))
#gg <- gg + ggtitle("Yield density")
#gg <- gg + xlab("Yield (kL / day)")
gg <- gg + theme_bw()
gg <- gg + theme(legend.title = element_blank())
gg <- gg + theme(axis.text.y = element_blank())
gg <- gg + theme(axis.ticks.y = element_blank())
gg <- gg + theme(axis.title.x = element_blank())
#gg <- gg + coord_cartesian(xlim = c(115, 175))
gg




#Yield participation plot
P <- Pe00
rL0 <- 1
rLmax_base <- 0.8
mu_r <- mu_cost_per_farmProduct_statQuo / P
sig2_r <- (mu_r * cv_cost_per_farmProduct_statQuo)^2
s2_yStar_implied <- sig2_r
m_yStar_implied <- m_yCeil_farm - mu_r
s_yStar_implied <- sqrt(s2_yStar_implied)
y <- seq(0, exp(m_yCeil_farm), 0.1)
df_y <- data.frame(y = y, f = dlnorm(y, meanlog = m_yStar_implied,
                                     sdlog = s_yStar_implied))
yStar_min <- exp(m_yCeil_farm - rL0)
yStar_max <- exp(m_yCeil_farm - 0)
df_y <- df_y %>% mutate(area = ifelse(y > yStar_min & y < yStar_max,
                                      "Participating", "Not Participating"))
yStar_max_base <- exp(m_yCeil_farm - rLmax_base)
df_y <- df_y %>% mutate(area = ifelse(y >= yStar_max_base & y < yStar_max,
                                      "Switch", area))
gg <- ggplot(data = df_y, aes(x = y, ymin = 0, ymax = f))
gg <- gg + geom_ribbon(aes(fill = factor("Not participating")))
gg <- gg + geom_ribbon(data = df_y[df_y$area == "Participating", ], aes(fill = area))
gg <- gg + geom_ribbon(data = df_y[df_y$area == "Switch", ], aes(fill = area))
gg <- gg + ggtitle("Yield density")
gg <- gg + xlab("Yield (MT / ha)")
gg <- gg + theme(legend.title = element_blank())
gg <- gg + theme(axis.text.y = element_blank())
gg <- gg + theme(axis.ticks.y = element_blank())
gg <- gg + coord_cartesian(xlim = c(9, 28))
gg

#Supply yield participation plot
Pe00 <- df_Eq00$Pe
P <- Pe00
rL0 <- 1
rLmax_base <- 0.8

# ratio_price <- P_input / P_output * (1 - l_credit)
# mu_r <- ratio_price * mu_beta
mu_r <- P / P_rev_per_output_DEM * mu_factry_efficiency_inv_statQuo
sig2_r <- (mu_r * cv_factry_efficiency_inv_statQuo)^2
s2_yStar_implied <- sig2_r
m_yStar_implied <- m_yCeil_factry - mu_r
s_yStar_implied <- sqrt(s2_yStar_implied)
y <- seq(0, exp(m_yCeil_factry), 0.1)
df_y <- data.frame(y = y, f = dlnorm(y, meanlog = m_yStar_implied,
                                     sdlog = s_yStar_implied))
yStar_min <- exp(m_yCeil_factry - rL0)
yStar_max <- exp(m_yCeil_factry - 0)
df_y <- df_y %>% mutate(area = ifelse(y > yStar_min & y < yStar_max,
                                      "Participating", "Not Participating"))
yStar_max_base <- exp(m_yCeil_factry - rLmax_base)
df_y <- df_y %>% mutate(area = ifelse(y >= yStar_max_base & y < yStar_max,
                                      "Switch", area))
gg <- ggplot(data = df_y, aes(x = y, ymin = 0, ymax = f))
gg <- gg + geom_ribbon(aes(fill = factor("Not participating")))
gg <- gg + geom_ribbon(data = df_y[df_y$area == "Participating", ], aes(fill = area))
gg <- gg + geom_ribbon(data = df_y[df_y$area == "Switch", ], aes(fill = area))
#gg <- gg + ggtitle("Yield density")
gg <- gg + xlab("Yield (kL / day)")
gg <- gg + theme(legend.title = element_blank())
gg <- gg + theme(axis.text.y = element_blank())
gg <- gg + theme(axis.ticks.y = element_blank())
gg <- gg + coord_cartesian(xlim = c(115, 175))
gg

#===========
# Demand participation plots
N = N_D
P_rev_per_output = P_rev_per_output_DEM_statQuo
mu_P_fdstkCost_per_output = Pe00
mu_P_procCost_per_output = mu_P_procCost_per_output_DEM_statQuo
cv_P_fdstkCost_per_output = cv_P_fdstkCost_per_output_DEM_statQuo
cv_P_procCost_per_output = cv_P_procCost_per_output_DEM_statQuo
beta = beta_DEM_statQuo
m_yCeil = m_yCeil_DEM_statQuo
s2_yCeil = s2_yCeil_DEM_statQuo
m_A = m_A_DEM_statQuo
s2_A = s2_A_DEM_statQuo
df_rL0max
l_credit = 0
  #--------------------------------
  # mu_r
  ratio_price <- (mu_P_fdstkCost_per_output + mu_P_procCost_per_output) / P_rev_per_output
  mu_r <- ratio_price * beta * (1 - l_credit)
  #--------------------------------
  # sig2_r
  sig2_fdstkCost_per_output <- (mu_P_fdstkCost_per_output * cv_P_fdstkCost_per_output)^2
  sig2_procCost_per_output <- (mu_P_procCost_per_output * cv_P_procCost_per_output)^2
  sig2_r <- (sig2_fdstkCost_per_output + sig2_procCost_per_output) * (beta / P_rev_per_output)^2
  #--------------------------------
  # s_qStar
  s2_qStar <- s2_A + s2_yCeil + sig2_r
  s_qStar <- sqrt(s2_qStar)
  #--------------------------------
  # mu_qStar
  m_qStar <- m_A + m_yCeil - mu_r
  mu_qStar <- exp(m_qStar + s2_qStar / 2)
  #--------------------------------
  # Nvr0, Nvr1
  # Note: if sig2_beta = 0 then so should s2_yCeil, and N_D should = 1
  if(cv_P_fdstkCost_per_output != 0 | cv_P_procCost_per_output != 0){
    rL0 <- df_rL0max$rL0
    rLmax <- df_rL0max$rLmax
    vrLmax <- (-rLmax + mu_r - s2_qStar) / s_qStar
    vrL0 <- (-rL0 + mu_r - s2_qStar) / s_qStar
    NvrLmax <- pnorm(vrLmax)
    NvrL0 <- pnorm(vrL0)
    #--------------------------------
    # QD or QS
    #mkt_participation <- (1 + NvrLmax - NvrL0) / 2
    mkt_participation <- NvrLmax - NvrL0
    Q_D_or_S <- N * mu_qStar * mkt_participation
  }else{
    Q_D_or_S <- mu_qStar
  }
  #--------------------------------
  if(nrow(df_rL0max) > 1){
    # ind1 <- which(df_rL0max$rL0 == 0)
    # ind2 <- which(df_rL0max$rLmax == 0)
    # ind0 <- intersect(ind1, ind2)
    # Q_D_or_S[ind0] <- 0
    # mkt_participation[ind0] <- NA
  }else{
    if(rL0 == 0 & rLmax == 0){
      Q_D_or_S <- 0
      mkt_participation <- NA
    }
  }
  #--------------------------------
  df_out <- data.frame(Q_D_or_S, mkt_participation)
  #--------------------------------
  
  
  y <- seq(-3, 3, 0.1)
  df_y <- data.frame(y = y, f = dnorm(y))
  df_y <- df_y %>% mutate(area = ifelse(y > vrL0 & y < vrLmax,
                                        "Participating", "Not Participating"))
  gg <- ggplot(data = df_y, aes(x = y, ymin = 0, ymax = f))
  gg <- gg + geom_ribbon(aes(fill = factor("Not participating")))
  gg <- gg + geom_ribbon(data = df_y[df_y$area == "Participating", ], aes(fill = area))
  #gg <- gg + geom_ribbon(data = df_y[df_y$area == "Switch", ], aes(fill = area))
  #gg <- gg + ggtitle("Yield density")
  #gg <- gg + xlab("Yield (kL / day)")
  gg <- gg + theme_bw()
  gg <- gg + theme(legend.title = element_blank())
  gg <- gg + theme(axis.text.y = element_blank())
  gg <- gg + theme(axis.ticks.y = element_blank())
  gg <- gg + theme(axis.title.x = element_blank())
  #gg <- gg + coord_cartesian(xlim = c(115, 175))
  gg
  
  
  #---
  # Demand yield plot
  s2_yStar_implied <- sig2_r
  m_yStar_implied <- m_yCeil_DEM_statQuo - mu_r
  s_yStar_implied <- sqrt(s2_yStar_implied)
  y <- seq(0, exp(m_yCeil_DEM_statQuo), 0.1)
  df_y <- data.frame(y = y, f = dlnorm(y, meanlog = m_yStar_implied,
                                       sdlog = s_yStar_implied))
  yStar_min <- exp(m_yCeil_DEM_statQuo - rL0)
  yStar_max <- exp(m_yCeil_DEM_statQuo - 0)
  df_y <- df_y %>% mutate(area = ifelse(y > yStar_min & y < yStar_max,
                                        "Participating", "Not Participating"))
  # yStar_max_base <- exp(m_yCeil_factry - rLmax_base)
  # df_y <- df_y %>% mutate(area = ifelse(y >= yStar_max_base & y < yStar_max,
  #                                       "Switch", area))
  gg <- ggplot(data = df_y, aes(x = y, ymin = 0, ymax = f))
  gg <- gg + geom_ribbon(aes(fill = factor("Not participating")))
  gg <- gg + geom_ribbon(data = df_y[df_y$area == "Participating", ], aes(fill = area))
  # gg <- gg + geom_ribbon(data = df_y[df_y$area == "Switch", ], aes(fill = area))
  #gg <- gg + ggtitle("Yield density")
  gg <- gg + xlab("Yield (kL / day)")
  gg <- gg + theme(legend.title = element_blank())
  gg <- gg + theme(axis.text.y = element_blank())
  gg <- gg + theme(axis.ticks.y = element_blank())
  gg <- gg + coord_cartesian(xlim = c(115, 140))
  gg
  
  
