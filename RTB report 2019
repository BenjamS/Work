---
title: "Economic challenges to the uptake of lower yielding small granule cassava"
author: Benjamin Schiek, Decision and Policy Analysis (DAPA), International Center for Tropical Agriculture
date: "`r Sys.Date()`"
bibliography: Small Granule Challenges.bib
biblio-style: apalike
header-includes:
  - \usepackage{float}
  - \floatplacement{figure}{H}
numbersections: true
output: 
  pdf_document:
    fig_caption: true
    number_sections: true
    latex_engine: xelatex
mainfont: Garamond
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE)

library(tidyverse)
library(patchwork)
library(kableExtra)
library(xtable)
library(ggrepel)
library(rootSolve)
#========================================================================
# Define functions
#========================================================================
#=============================================================
# Tech adoption
#=============================================================
get_adopt_range <- function(delta_h, delta_P, quietly = T){
  # delta_h <- .9
  # delta_P <- 0.95 # Must be > delta_h?
  deltas <- delta_h * delta_P
  ly_switch <- log(delta_P) / (1 - 1 / deltas)
  #if(delta_P > 1){
  #--
  if(deltas > 1){
    tech_is_pro_poor <- T
  }else{
    tech_is_pro_poor <- F
  }
  #--
  if(ly_switch > -1 & ly_switch < 0){
    if(tech_is_pro_poor){
      adopt_bounds <- c(-1, ly_switch)
    }else{
      adopt_bounds <- c(ly_switch, 0)
    }
  }else{
    if(ly_switch < -1){
      if(tech_is_pro_poor){
        adopt_bounds <- NA  
      }else{
        adopt_bounds <- c(-1, 0)
      }
    }
    if(ly_switch > 0){
      if(tech_is_pro_poor){
        adopt_bounds <- c(-1, 0)
      }else{
        adopt_bounds <- NA
      }
    }
  }
  #--
  zero_or_full <- NA
  if(adopt_bounds[1] == -1 & adopt_bounds[2] == 0){
    zero_or_full <- "Full adoption"
  }
  if(is.na(adopt_bounds)){
    zero_or_full <- "Zero adoption"
  }
  
  if(!quietly){
    print("Adoption log yield (normalized) bounds:")
    print(adopt_bounds)
    print("ly_switch:")
    print(ly_switch)
    if(tech_is_pro_poor){
      print("Tech is pro-poor")
    }else{
      print("Tech is not pro-poor")
    }
    print(zero_or_full)
  }
  #--
  out_list <- list(adopt_bounds, tech_is_pro_poor, ly_switch, zero_or_full)
  return(out_list)
}    


graph_diffNR1NR0 <- function(delta_h, delta_P, yCeil){
  ly0_vec <- seq(-1, 0, length.out = 25)
  
  deltas <- delta_h * delta_P
  ly_switch <- log(delta_P) / (1 - 1 / deltas)
  
  R_0 <- yCeil * exp(ly0_vec)
  R_1 <- yCeil * exp(ly0_vec / deltas) * delta_P
  diff_NR1NR0 <- R_1 - R_0
  df_plot <- data.frame(ly0_vec, diff_NR1NR0)
  gg <- ggplot(df_plot, aes(x = ly0_vec, y = diff_NR1NR0))
  gg <- gg + geom_line()
  gg <- gg + geom_hline(yintercept = 0, color = "violet", size = 1)
  #    gg <- gg + geom_vline(xintercept = ly_switch, color = "violet", size = 1)
  gg <- gg + labs(x = "Log yield index", y = expression("Diff. in net rev. ("*ha.^-1 ~Price^-1*")"))
  gg
  
}


# delta_h <- 1.1
# delta_P <- 1.03
# out <- get_adopt_range(delta_h, delta_P, quietly = T)
# adopt_bounds <- out[[1]]
# tech_is_pro_poor <- out[[2]]
# adopt_bounds
# tech_is_pro_poor
# graph_diffNR1NR0(delta_h, delta_P, yCeil)

get_lq_bounds <- function(adopt_bounds, tech_is_pro_poor, which_tech, zero_or_full){
  if(which_tech == "baseline"){
    if(!is.na(zero_or_full)){
      if(zero_or_full == "Zero adoption"){
        lq_bounds <- c(-1, 0)
      }
      if(zero_or_full == "Full adoption"){
        lq_bounds <- NA
      }
      
    }else{
      if(tech_is_pro_poor){
        lq_lower <- adopt_bounds[2]
        lq_upper <- 0
      }else{
        lq_lower <- -1
        lq_upper <- adopt_bounds[1]
      }
      lq_bounds <- c(lq_lower, lq_upper)
      
    }
    
  }
  
  if(which_tech == "new"){
    lq_bounds <- adopt_bounds
  }
  
  return(lq_bounds)
}

#=============================================================
# Supply function
#=============================================================
QS_at_P <- function(P, QS_env){
  mu_alpha <- QS_env[["mu_alpha"]]
  sig_alpha <- QS_env[["sig_alpha"]]
  yCeil <- QS_env[["yCeil"]]
  m_A <- QS_env[["m_A"]]
  s_A <- QS_env[["s_A"]]
  N <- QS_env[["N"]]
  lq_bounds <- QS_env[["lq_bounds"]]
  
  m_y <- log(yCeil) + mu_alpha / P
  s_y <- sig_alpha / P
  mu_y <- exp(m_y + s_y^2 / 2)
  
  mu_A <- exp(m_A + s_A^2 / 2)
  
  mu_q <- mu_y * mu_A
  
  s_q <- s_A + s_y
  
  supply_is_zero <- F
  if(is.null(lq_bounds)){
    lq_lower <- -1
    lq_upper <- 0
  }else{
    if(is.na(lq_bounds)){
      supply_is_zero <- T
    }else{
      lq_lower <- lq_bounds[1]
      lq_upper <- lq_bounds[2]
    }
    
  }
  
  if(supply_is_zero){
    mkt_particip <- 0
    QS <- 0
  }else{
    u_upper <- (lq_upper - mu_alpha / P) / s_q
    u_lower <- (lq_lower - mu_alpha / P) / s_q
    
    theta_upper <- u_upper - s_q
    theta_lower <- u_lower - s_q
    
    N_upper <- pnorm(theta_upper)
    N_lower <- pnorm(theta_lower)
    mkt_particip <- N_upper - N_lower
    QS <- N * mu_q * mkt_particip
  }
  out_vec <- c(P, QS, mkt_particip)
  
  return(out_vec)
}
#-------------------------------------------------------------
QS_curve <- function(P_vec, QS_env){
  list_out <- purrr::map(P_vec, QS_at_P, QS_env)
  return(list_out)
}
#=============================================================
# Demand curve
#=============================================================
Q_NR_hm1_firm <- function(gamma, P_output, yCeil, C = NULL, C_per_Q = NULL, A = 1, quietly = T){
  
  if((is.null(C_per_Q) & is.null(C)) | (!is.null(C_per_Q) & !is.null(C))){
    print("Both C_per_Q and C can't be NULL/not NULL. Choose one or the other.")
  }
  
  # gamma = gamma_DEM
  # P_output = P_output_DEM_squo
  # yCeil = yCeil_DEM_squo
  # C = C_DEM_squo
  # C_per_Q = C_per_Q_DEM_squo
  # A = 1
  # 
  # yCeil = yCeil_DEM_new

  
  if(!is.null(C)){
    arg <- -C * gamma / (yCeil * P_output)
    Q <- A * yCeil * exp(lamW::lambertWm1(arg))
    #Q <- A * yCeil * exp(lamW::lambertW0(arg))
    #Q <- A * yCeil * exp(VGAM::lambertW(arg))
    #L <- Q * P_output - C * gamma
    NR <- Q * P_output - C
    
  }
  
  if(!is.null(C_per_Q)){
    alpha <- -C_per_Q * gamma
    Q <- A * yCeil * exp(alpha / P_output)
    #L <- Q * (P_output - C_per_Q * gamma)
    NR <- Q * (P_output - C_per_Q)
    
  }
  
  outvec <- c(Q, NR)
  
  if(!quietly){
    print("Q and NR:")
    print(outvec)
  }
  
  return(outvec)
}
#-------------------------------------------------------------
QD_input_mix <- function(P, QD_rootfn_env){

  if(!is.null(QD_rootfn_env[["delta_P"]])){
    delta_P <- QD_rootfn_env[["delta_P"]]
    P_alt <- delta_P * P
    QD_rootfn_env[["P_input_vec"]] <- c(P, P_alt)
  }else{
    QD_rootfn_env[["P_input_vec"]] <- P
  }
  
  n_inputs <- length(QD_rootfn_env[["a_DEM_vec"]])
  var_solve_vec <- rep(50, n_inputs + 1)
  out <- nleqslv::nleqslv(var_solve_vec, QD_rootfn, jac = NULL, QD_rootfn_env)
  QD_inputs <- out[1:n_inputs]
  QgammaRatio_output <- out[n_inputs + 1]
  # common_factor <- P_output_DEM * Q_gamma_ratio
  # QD <- sqrt(a_DEM / P * common_factor)
  out_vec <- c(P, QD_inputs, QgammaRatio_output)
  return(out_vec)
}
#-------------------------------------------------------------
QD_curve <- function(P_vec, QD_rootfn_env){
  list_out <- purrr::map(P_vec, QD_input_mix, QD_rootfn_env)
  return(list_out)
}
#-------------------------------------------------------------
QD_rootfn <- function(var_solve_vec, QD_rootfn_env){
  
  a_DEM_vec <- QD_rootfn_env[["a_DEM_vec"]]
  P_input_vec <- QD_rootfn_env[["P_input_vec"]]
  P_proc_vec <- QD_rootfn_env[["P_proc_vec"]]
  P_output_DEM <- QD_rootfn_env[["P_output_DEM"]]
  C_DEM <- QD_rootfn_env[["C_DEM"]]
  #kl_per_MT_vec <- QD_rootfn_env[["kl_per_MT_vec"]]
  #C_process_per_kL <- QD_rootfn_env[["C_process_per_kl"]]

  n_inputs <- length(a_DEM_vec)
  QD_vec <- var_solve_vec[1:n_inputs]
  Q_gamma_ratio <- var_solve_vec[n_inputs + 1]
  common_factor <- P_output_DEM * Q_gamma_ratio
  P_input_tot_vec <- P_input_vec + P_proc_vec
  slack_q <- QD_vec^2 - a_DEM_vec / P_input_tot_vec * common_factor
  slack_c <- C_DEM - sum(QD_vec * P_input_tot_vec)
  
  slack_vec <- c(slack_q, slack_c)

  return(slack_vec)

}


# p0 <- 2000
# p1 <- p0 * 1.04
# QD_rootfn_env <- list()
#   QD_rootfn_env[["a_DEM_vec"]] <- c(a_root_squo, a_root_1)
#   QD_rootfn_env[["P_vec"]] <- c(p0, p1)
#   QD_rootfn_env[["P_output_DEM"]] <- P_output_DEM_squo
#   QD_rootfn_env[["C_DEM"]] <- C_DEM_squo
#   QD_rootfn_env[["kl_per_MT_vec"]] <- c(kl_per_MT_squo, kl_per_MT_1)
#   QD_rootfn_env[["C_process_per_kl"]] <- C_process_per_kL_squo
# 
# QD_vec <- c(50, 50, 50)
# nleqslv::nleqslv(QD_vec, QD_rootfn, jac = NULL, QD_rootfn_env)

#=============================================================
# Equilibrium
#=============================================================
equilib_rootfn <- function(P_vec, QS_env, QD_rootfn_env, which_QD){
  
  QS <- QS_curve(P_vec, QS_env)
  QS <- as.data.frame(do.call(rbind, QS))
  QS <- QS[, 2]
  
  QD <- QD_curve(P_vec, QD_rootfn_env)
  QD <- as.data.frame(do.call(rbind, QD))
  QD <- QD[, which_QD]

  slack <- QS - QD
  
  return(slack)
} 

QSQD_Equilib <- function(interval_P, QS_env, QD_rootfn_env, alt_input){
  
  if(!is.null(QD_rootfn_env[["delta_P"]])){
    if(alt_input){
      which_QD <- 3
    }else{
      which_QD <- 2
    }
  }else{
      which_QD <- 2
  }

  P_E <- uniroot.all(equilib_rootfn,
                     interval_P,
                     lower = min(interval_P),
                     upper = max(interval_P),
                     QS_env = QS_env,
                     QD_rootfn_env = QD_rootfn_env,
                     which_QD = which_QD)
  
  QS_vec <- QS_at_P(P_E, QS_env)
  QD_vec <- QD_input_mix(P_E, QD_rootfn_env)
  list_equilib <- list()
  list_equilib[["QS_vec"]] <- QS_vec
  list_equilib[["QD_vec"]] <- QD_vec
  return(list_equilib)
  
}
#=============================================================
#=============================================================
#=============================================================
# End function definitions
#=============================================================
#=============================================================
#=============================================================


```
# Introduction: economic agency matters

Technological breakthroughs in bioethanol extraction procedures have given rise to much optimism surrounding cassava ethanol (CE) production over the past ten years. Sriroth et al. [-@sriroth2010promise], for example, calculated that, given new factory techniques, the world could enjoy CE output of 15 billion liters per year---*if* only cassava yields could be nudged upwards by 5 MT/ha. However, this is a big "if" that ignores the economic dimension of the problem. During the green revolution, neglect of the economic dimension may have been justified, as free market incentives were largely overriden by government programs (such as the Masagana 99 rice program in the Philippines). But in today's free market environments, production is as much a function of prices as it is of biophysical parameters. 

The question of economic agency is especially pertinent in the case of small granule cassava, which offers a factory efficiency gain but is lower yielding than the baseline industrial root variety. The only reason cassava farmers would want to switch to small granule cassava is if they could expect to receive a premium over and above the basline root price high enough to compensate for the yield loss.

# Empirical evidence of cassava farm price responsiveness

Since the small granule uptake strategy rests entirely on the assumption that cassava farmers are price responsive, it is worth taking a moment to examine the empirical evidence behind this assumption. A cursory look at the FAO data reveals some correlation between the cassava farm gate price and production; but the picture is inconclusive when compared to the tight relation observed in the rice supply curve (Figure \ref{fig:FAOsupplyCurves}). What does the literature have to say?

```{r, fig.show="hold", fig.align="center", fig.height=5, fig.width=8, fig.cap="\\label{fig:FAOsupplyCurves}Historical price-production relation, Thailand. (Source: FAO series 1991-2016. Price = Value of Agricultural Production / Production).", echo=FALSE}

df_vap_raw <- read.csv("Value_of_Production_E_All_Data.csv", stringsAsFactors = F)
#colnames(df_vap_raw)
df_vap_raw$Area.Code <- NULL
df_vap_raw$Item.Code <- NULL
df_vap_raw$Element.Code <-NULL
u <- colnames(df_vap_raw)
#colnames(df_vap_raw)
df_vap_raw <- df_vap_raw[, -grep("F", u)]
colnames(df_vap_raw)[5:ncol(df_vap_raw)] <- as.character(c(1961:(1961 + ncol(df_vap_raw) - 5)))
df_vap_raw <- gather(df_vap_raw,Year,Value,`1961`:`2016`)
#------------------
#unique(df_vap_raw$Area)[grep("africa", unique(df_vap_raw$Area), ignore.case = T)]
#unique(df_vap_raw$Item)[grep("rice", unique(df_vap_raw$Item), ignore.case = T)]
#------------------
area_vec <- c("Thailand")
item_vec <- c("Rice, paddy", "Cassava")
#------------------
df_vap <- subset(df_vap_raw, Area %in% area_vec)
df_vap <- subset(df_vap, Item %in% item_vec)
#unique(df_vap_raw$Element)
#element_vec <- c("Gross Production Value (current million US$)")
element_vec <- c("Gross Production Value (current million SLC)")
df_vap <- subset(df_vap, Element %in% element_vec)
#df_vap <- subset(df_vap, Year > 1990)
df_vap$Unit <- NULL
df_vap$Element <- NULL
df_vap$Value <- df_vap$Value * 10^6
colnames(df_vap)[4] <- "Gross Production Value (current USD)"
colnames(df_vap)[4] <- "Gross Production Value (current SLC)"
#------------------------------
# Get production data
df_prod_raw <- read.csv("Production_Crops_E_All_Data.csv", stringsAsFactors = F)
df_prod_raw <- subset(df_prod_raw, Item.Code != 2928)
df_prod_raw$Area.Code <- NULL
df_prod_raw$Item.Code <- NULL
df_prod_raw$Element.Code <-NULL
u <- colnames(df_prod_raw)
df_prod_raw <- df_prod_raw[, -grep("F", u)]
last_yr <- (1961 + ncol(df_prod_raw) - 5)
colnames(df_prod_raw)[5:ncol(df_prod_raw)] <- as.character(c(1961:last_yr))
gathercols <- colnames(df_prod_raw)[5:ncol(df_prod_raw)]
df_prod_raw <- gather_(df_prod_raw, "Year", "Value", gathercols)
#------------------------------
#unique(df_prod_raw$Item)[grep("beans", unique(df_prod_raw$Item), ignore.case = T)]
df_prod_yield <- subset(df_prod_raw, Item %in% item_vec)
df_prod_yield <- subset(df_prod_yield, Area %in% area_vec)
#df_prod_yield <- subset(df_prod_yield, Year == 2014)
df_prod_yield$Unit <- NULL
#df_prod_yield <- subset(df_prod_yield, Element %in% c("Yield", "Production"))
df_prod_yield <- df_prod_yield %>% spread(Element, Value)
df_prod_yield$Yield <- df_prod_yield$Yield / 10000
df_prod_yield$Production <- df_prod_yield$Production / 1000
df_prod_yield$`Area harvested` <- df_prod_yield$`Area harvested` / 1000
colnames(df_prod_yield)[4:6] <- c("Area harvested ('000 Ha)", "Production ('000 MT)", "Yield (MT)")
#------------------------------
# df_plot <- subset(df_prod_yield, Item == "Rice, paddy")
# df_plot$x <- log(df_plot$`Area harvested ('000 Ha)`)
# df_plot$y <- log(df_plot$`Yield (MT)`)
# gg <- ggplot(df_plot, aes(x, y))
# gg <- gg + geom_point()
# gg
#------------------------------
df_price <- merge(df_vap, df_prod_yield, by = c("Area", "Year", "Item"))
df_price$`Price (Baht / MT)` <- df_price$`Gross Production Value (current SLC)` / df_price$`Production ('000 MT)` * 10^-3
#------------------------------
# df_exPrice_raw <- read.csv("Trade_Crops_Livestock_E_All_Data.csv", stringsAsFactors = F)
# df_exPrice_raw <- subset(df_exPrice_raw, Item.Code != 2928)
# df_exPrice_raw$Area.Code <- NULL
# df_exPrice_raw$Element.Code <-NULL
# df_exPrice_raw$Item <- as.character(df_exPrice_raw$Item)
# df_exPrice_raw$Element <- as.character(df_exPrice_raw$Element)
# df_exPrice_raw$Area <- as.character(df_exPrice_raw$Area)
# u <- colnames(df_exPrice_raw)
# df_exPrice_raw <- df_exPrice_raw[, -grep("F", u)]
# colnames(df_exPrice_raw)[6:ncol(df_exPrice_raw)] <- as.character(c(1961:2016))
# df_exPrice_raw <- gather(df_exPrice_raw, Year, Value, `1961`:`2016`)
# rm(u)
# colnames(df_exPrice_raw)
# unique(df_exPrice_raw$Element)
# df_exPrice_raw$Item.Code <- NULL
# df_exPrice <- subset(df_exPrice_raw, Element %in% c("Export Quantity", "Export Value"))
# df_exPrice$Unit <- NULL
# df_exPrice <- subset(df_exPrice, Item == "Cassava Equivalent")
# df_exPrice <- subset(df_exPrice, Area %in% area_vec)
# df_exPrice <- df_exPrice %>% spread(Element, Value)
# df_exPrice$`Export Price` <- df_exPrice$`Export Value` / df_exPrice$`Export Quantity`
# #------------------------------
# df_plot <- merge(df_price, df_exPrice[, c("Area", "Year", "Export Price")], by = c("Area", "Year"))
# df_plot <- subset(df_plot, Year > 1990)
# gg <- ggplot(df_plot, aes(x = `Export Price`, y = Price, label = Year))
# gg <- gg + geom_point()
# gg <- gg + geom_text_repel()
# gg

xmin_adj <- 0.25
xmax_adj <- 1.45
ymax_adj <- 1.25

df_plot <- subset(df_price, Item == "Rice, paddy")
ind_price_not_NA <- which(!is.na(df_plot$`Price (Baht / MT)`))
xmin <- min(df_plot$`Production ('000 MT)`[ind_price_not_NA], na.rm = T) * xmin_adj
xmax <- max(df_plot$`Production ('000 MT)`[ind_price_not_NA], na.rm = T) * xmax_adj
ymin <- 0
ymax <- max(df_plot$`Price (Baht / MT)`, na.rm = T) * ymax_adj
gg <- ggplot(df_plot, aes(x = `Production ('000 MT)`, y = `Price (Baht / MT)`, label = Year))
gg <- gg + geom_point()
gg <- gg + geom_text_repel()
gg <- gg + labs(title = "Rice")
gg <- gg + coord_cartesian(xlim = c(xmin, xmax), ylim = c(ymin, ymax) )
#gg
gg_rice <- gg

df_plot <- subset(df_price, Item == "Cassava")
ind_price_not_NA <- which(!is.na(df_plot$`Price (Baht / MT)`))
xmin <- min(df_plot$`Production ('000 MT)`[ind_price_not_NA], na.rm = T) * xmin_adj
xmax <- max(df_plot$`Production ('000 MT)`[ind_price_not_NA], na.rm = T) * xmax_adj
ymin <- 0
ymax <- max(df_plot$`Price (Baht / MT)`, na.rm = T) * ymax_adj
gg <- ggplot(df_plot, aes(x = `Production ('000 MT)`, y = `Price (Baht / MT)`, label = Year))
gg <- gg + geom_point()
gg <- gg + geom_text_repel()
gg <- gg + theme(axis.title.y = element_blank())
gg <- gg + labs(title = "Cassava")
gg <- gg + coord_cartesian(xlim = c(xmin, xmax), ylim = c(ymin, ymax) )
#gg
gg_cassava <- gg

(gg_rice | gg_cassava) + plot_layout(ncol = 2)

rm(df_price, df_prod_raw, df_prod_yield, df_vap_raw, df_vap, df_plot)
#gc()


```

On the one hand, numerous studies have found that agricultural production, in the aggregate, is unresponsive to price movements^[It is, however, responsive to changes in human and physical capital (infrastructural improvements, education, etc.)]. The explanation offered for this is that aggregate agricultural production is limited by price-invariant physical constraints such as land availability and biophysical yield ceilings [@schafer1987farm; @rao1989agricultural]. Haile, Kalkuhl, and von Braun point to another culprit: high price volatility [-@haile2015worldwide]. It is a little recognized, but plain empirical fact, that higher prices go hand in hand with higher volatility (Figure \ref{fig:riskReward}).^[Note in figure \ref{fig:riskReward} that this is true for distinct crops as well as for distinct intermediate products issuing from a single given crop.] For risk-averse small farmers, a high price is not enough. They must also be assured that the associated increase in risk will be offset via price floors, insurance, and/or other public or private risk pooling mechanisms.

```{r, fig.show="hold", fig.align="center", fig.cap="\\label{fig:riskReward}Historical relation between expected price and price volatility. (Source: Author's calculation using Faostat series 1974-2008.\n'Price' = World Export Value / World Export Qty.", echo=FALSE}

ExportData_raw <- read.csv("Trade_Crops_Livestock_E_All_Data.csv")
ExportData_raw <- subset(ExportData_raw, Item.Code != 2928)
ExportData_raw$Area.Code <- NULL
ExportData_raw$Element.Code <-NULL
ExportData_raw$Item <- as.character(ExportData_raw$Item)
ExportData_raw$Element <- as.character(ExportData_raw$Element)
ExportData_raw$Area <- as.character(ExportData_raw$Area)
u <- colnames(ExportData_raw)
ExportData_raw <- ExportData_raw[, -grep("F", u)]
u <- colnames(ExportData_raw)[6:ncol(ExportData_raw)]
df_x <- ExportData_raw
rm(ExportData_raw)
colnames(df_x)[6:ncol(df_x)] <- gsub("Y", "", u)
df_x <- gather(df_x, Year, Value, `1961`:`2017`)
rm(u)
#----------------------------------
#unique(ExportData_raw$Item)
# which(unique(ExportData_raw$Item) == "Rice")
# unique(ExportData_raw$Item)[105]
#unique(ExportData_raw$Item)[grep("Rubber",unique(ExportData_raw$Item))]
ExportData <- subset(df_x, Element %in% c("Export Quantity", "Export Value"))
ExportData <-  subset(ExportData, Area %in% c("World"))
#ExportData <- subset(ExportData, Item %in% c("Sorghum", "Maize", "Wheat", "Cassava Equivalent") | Item.Code %in% c(30))
# ExportData <- subset(ExportData, Item %in% c("Maize", "Cassava dried",
#                         "Coffee, green", "Wheat", "Bananas", "Plantains",
#                         "Potatoes", "Cassava Equivalent", "Cocoa, beans", "Wool, greasy",
#                         "Beans, dry", "Cotton lint", "Silk", "Apples", "Oil, soybean",
#                         "Rubber, natural", "Rice"))

ExportData <- subset(ExportData, Item %in% c("Maize", "Cassava dried", "Flour, wheat", "Starch, cassava",
                                             "Coffee, green", "Coffee, roasted", "Wheat", "Bananas", "Plantains",
                                             "Potatoes", "Cassava Equivalent", "Cocoa, beans", "Wool, greasy",
                                             "Beans, dry", "Cotton lint", "Silk", "Apples", "Soybeans", "Oil, soybean",
                                             "Rubber, natural", "Rice", "Cocoa, butter"))


#ExportData <- subset(ExportData, Item %in% c("Barley", "Maize","Cassava dried","Coffee, green","Flour, wheat" ,"Bananas and plantains","Pulses","Coffee, roasted","Millet","Rye","Wheat","Sorghum","Potatoes","Starch, cassava","Cassava Equivalent") | Item.Code %in% c(30,1955))
#ExportData <-  subset(ExportData, Area %in% c("Thailand","United States of America", "World"))
#ExportData <- subset(ExportData, Item %in% c("Maize","Cassava Equivalent","Wheat","Sorghum", "Barley") | Item.Code %in% c(30,1955))
#ExportData <- subset(ExportData, Item %in% c("Wheat","Maize","Millet","Rye","Sorghum") | Item.Code %in% c(30))
#ExportData <- subset(ExportData, Item %in% c("Wheat","Maize","Barley","Sorghum", "Cassava Equivalent") | Item.Code %in% c(30,1955))
#ExportData <- subset(ExportData, Item %in% c("Cassava Equivalent","Maize","Sorghum", "Wheat") | Item.Code %in% c(30,1955))
ExportData$Item.Code <- NULL
#ExportData <- subset(ExportData_raw, Item %in% c("Cassava Equivalent", "Cereals"))
#ExportData <- subset(ExportData_raw,Item %in% c("Cassava dried","Flour, maize","Flour, wheat","Sorghum","Starch, cassava"))
#----------------------------------
ExportData$Unit <- NULL
ExportData$Value[which(is.na(ExportData$Value))] <- 0
ExportData_wide <- spread(ExportData, Element, Value)
ExportData_wide <- ExportData_wide[order(ExportData_wide$Area, ExportData_wide$Year),]
ExportData_wide$`Price` <- NA
ExportData_wide$`Price` <- 1000 * as.numeric(ExportData_wide$`Export Value`) / as.numeric(ExportData_wide$`Export Quantity`)
#ExportData_wide$`Export Quantity` <- NULL
#ExportData_wide$`Export Value` <- NULL
ExportData_wide$Year <- as.integer(ExportData_wide$Year)

u <- ExportData_wide$Item
ExportData_wide$Item[grep("Rice", u)] <- "Rice"
ExportData_wide$Item[grep("Sugar", u)] <- "Sugar"
#ExportData_wide$Item[grep("Maize", u)] <- "Corn"
ExportData_wide$Item[grep("Beans", u)] <- "Beans"
ExportData_wide$Item[grep("Oil, soybean", u)] <- "Soybean oil"
ExportData_wide$Item[grep("Cassava dried", u)] <- "Dried cassava"
ExportData_wide$Item[grep("Starch, cassava", u)] <- "Cassava starch"
ExportData_wide$Item[grep("Flour, wheat", u)] <- "Wheat flour"
ExportData_wide$Item[grep("Wool", u)] <- "Wool"


rm(u)

ExportData_wide <- ExportData_wide %>% gather(Var, Value, `Export Quantity`:Price)

FaoPrice_wide_allYrs <- spread(ExportData_wide, Item, Value)
FaoPrice_wide_allYrs$Area <- NULL
# u <- colnames(FaoPrice_wide_allYrs)[2:ncol(FaoPrice_wide_allYrs)]
# colnames(FaoPrice_wide_allYrs)[2:ncol(FaoPrice_wide_allYrs)] <- paste(u,"Price")
# rm(u)
#---------------------------------
FaoPrice_wide <- subset(FaoPrice_wide_allYrs,Year %in% c(1974:2008))
#FaoPrice_wide$t <- c(1:nrow(FaoPrice_wide))
#FaoPrice_wide <- FaoPrice_wide[,c(1,ncol(FaoPrice_wide),2:(ncol(FaoPrice_wide)-1))]
#mod <- lm(log(`Corn Price`) ~ t,FaoPrice_wide)
#mod <- lm(log(`Wheat Price`) ~ t,FaoPrice_wide)
#summary(mod)
#?lm
gathercols <- colnames(FaoPrice_wide)[c(3:ncol(FaoPrice_wide))]
FaoPrice_long <- gather_(FaoPrice_wide, "Item", "Value", gathercols)
FaoPrice_long <- FaoPrice_long %>% spread(Var, Value)

FaoPrice_long$lPrice <- log(FaoPrice_long$Price)
gg <- ggplot(FaoPrice_long,aes(x = Year, y = Price, group = Item, color = Item)) + geom_line()
#gg

df_mu_sd <- FaoPrice_long %>% group_by(Item) %>% summarise(mu = mean(Price), 
                                                           sd = sd(Price), `Export Qty.` = mean(`Export Quantity`), 
                                                           `Export Value\n(1000 USD)` = mean(`Export Value`))
df_mu_sd$lmu <- log(df_mu_sd$mu)
df_mu_sd$lsd <- log(df_mu_sd$sd)
df_mu_sd$lQty <- log(df_mu_sd$`Export Qty.`)
mod <- lm(lmu ~ lsd, df_mu_sd)
#summary(mod)
yint <- round(mod$coefficients[1], 2)
slope <- round(mod$coefficients[2], 2)

gg <- ggplot(df_mu_sd, aes(x = lsd, y = lmu)) + geom_point(aes(size = `Export Value\n(1000 USD)`))
#gg <- gg + geom_text(aes(label = Item), angle = 0, hjust=-0.1, vjust=0, size = 5)
gg <- gg + geom_text_repel(aes(label = Item), size = 5)
#gg <- gg + geom_abline(intercept = mod$coefficients[1], slope = mod$coefficients[2])
gg <- gg + ggtitle(paste0("Slope = ", as.character(slope), "  Y intercept = ", as.character(yint))) + theme(plot.title = element_text(size=12))
gg <- gg + labs(x = "Nat. Log(standard deviation of price)", y = "Nat. Log(mean price)")#, caption = "Source: Author's calculation using Faostat series 1974-2008.\n'Price' = World Export Value / World Export Qty.")
#gg <- gg + labs(caption = "Source: Authors' creation using Faostat series 1974-2008. 'Price' = World Export Value / World Export Qty.")
#gg <- gg + stat_smooth(method = lm, se = FALSE)
gg

rm(df_x, ExportData, ExportData_wide, FaoPrice_wide_allYrs, FaoPrice_wide, FaoPrice_long)

```


On the other hand, these same studies conclude that farmers _are_ responsive to changes in crop prices _relative to one another_. In a parallel vein, Chaisinboon and Chontanawat found significant responsiveness among Thai cassava farmers to changes in the prices of different cassava products---chips, pellets, starch, and ethanol---relative to one another [-@chaisinboon2011factors]. In South East Asia generally, this is corroborated by recent evidence of small farmers switching betweeen crops as well as between different end uses of a single given crop in response to relative price movements [@newby2018].

# Modeling the supply response to release of small granule cassava

Having presented assurances that Thai cassava farmers are price responsive, it is time to turn to the question of small granule adoption in more detail. Experiments conducted in 2016 found that factory use of small granule cassava instead of the baseline root variety resulted in a 14% increase in Simultaneous Liquefaction, Saccharification, and Fermentation CE production [@TranSLSFdata]. However, small granule cassava is also known to be lower yielding than the baseline variety. This means that farmers will not adopt small granule cassava unless CE factories pay them a sufficiently higher price to compensate for the yield loss relative to the baseline variety.

Under weak economic assumptions^[1) Farms and factories want to maximize their net income given land and budget constraints; 2) farms and factories have a positive supply response to increases in the price of their product; 3) marginal returns to farm and factory inputs are diminishing; 4) farm yields follow a lognormal distribution. The model also depends upon several technical factory and farm parameters. See appendix for mathematical details.], the precise supply response to release of small granule cassava depends upon the expected small granule root yield loss relative to the baseline variety, the expected baseline root harvest price, and the expected premium paid out by the factory over and above the baseline price.^[Farmers and factories must generally agree upon these three pieces of information, or else market chaos will ensue.]

Clearly, if the small granule premium offered by the factory is high enough, cassava farmers will begin to split into two populations: those who switch to small granule, and those who remain with the baseline variety. However, careful economic modeling is required to determine precisely how many farmers switch to the new variety and how many remain with the baseline. Moreover, there is a third group that requires careful consideration: those who enter or exit the market, attracted or repelled by the new opportunity. And careful modeling is also required to disaggregate the supply response into its three components: 1) the yield response, due to changes in farm expenditures on inputs, 2) the area response, due to expansion or contraction of the planted area, and 3) the entry/exit of farmers into/from the market.

```{r, fig.show="hold", fig.align="center", fig.cap="\\label{fig:supply_particip_exercise}(Top) Supply curves for small granule and baseline variety cassava. The composite supply curve is also plotted. (Bottom) Their corresponding Market\nParticipation curves. The background color indicates the small granule adoption rate.", echo=FALSE}

#=============================================================
#=============================================================
# Define parameters
#-------------------------------------------------------------
# Supply
#-------------------------------------------------------------
C_per_Q_at_mu <- 1700
gamma_at_mu <- 1
h_at_mu <- -0.75
mu_alpha <- C_per_Q_at_mu / h_at_mu * gamma_at_mu
cv_alpha <- 0.11
sig_alpha <- abs(mu_alpha * cv_alpha)
yCeil <- 40
m_A <- log(2)
cv_A <- 0.15
s_A <- m_A * cv_A
N <- 40
lq_bounds <- NULL
#-------------------------------------------------------------
# Demand
#-------------------------------------------------------------
# QD <- N_D * P_output / (P * gamma_D) * a_e
P_E_squo <- 2000 # observed equilibrium price
Q_E_squo <- 350 # observed demand (equilibrium qty)
kl_per_MT_squo <- 1 / 6
#Q_output_DEM_squo <- 200 # ethanol kl
Q_output_DEM_squo <- Q_E_squo * kl_per_MT_squo
P_output_DEM_squo <- 22300
C_proc_per_kl_squo <- 9000
C_proc_per_MT_squo <- C_proc_per_kl_squo / kl_per_MT_squo
C_DEM_squo <- Q_E_squo * (P_E_squo + C_proc_per_kl_squo * kl_per_MT_squo)
# C_DEM_squo <- Q_E_squo * P_E_squo + C_proc_per_kl_squo * Q_output_DEM_squo
# C_proc_per_kl_squo * Q_output_DEM_squo
# C_proc_per_kl_squo * kl_per_MT_squo * Q_E_squo
C_per_Q_DEM_squo <- C_DEM_squo / Q_output_DEM_squo
yCeil_DEM_squo <- 150
gamma_DEM <- -log(Q_output_DEM_squo / yCeil_DEM_squo) * P_output_DEM_squo / C_per_Q_DEM_squo
#print(paste("gamma_DEM =", round(gamma_DEM, 2)))
#---
#Check
outvec <- Q_NR_hm1_firm(gamma_DEM, P_output_DEM_squo, yCeil = yCeil_DEM_squo, C_per_Q = C_per_Q_DEM_squo, quietly = T)
Q_ethanol_squo <- outvec[1]
NR_squo <- outvec[2]
#Q_output_DEM_squo * P_output_DEM_squo - C_DEM_squo
#---
#common_factor <- QD_squo * gamma_DEM / (P_output_squo * kl_per_MT_squo)
common_factor <- Q_output_DEM_squo * P_output_DEM_squo / gamma_DEM
P_E_tot_squo <- P_E_squo + kl_per_MT_squo * C_proc_per_kl_squo
a_root_squo <- Q_E_squo^2 * P_E_tot_squo / common_factor


#a_root_squo <- QD_squo * P_E_squo * gamma_DEM / (P_output_squo * kl_per_MT_squo)
#a_proc_squo <- Q_E_squo^2 * P_proc_squo / common_factor
#-------------------------------------------------------------
small_granule_eff_gain <- 1.14
kl_per_MT_1 <- small_granule_eff_gain * kl_per_MT_squo
common_factor_1 <- common_factor * kl_per_MT_1
P_E_tot_1 <- P_E_squo + kl_per_MT_1 * C_proc_per_kl_squo
a_root_1 <- Q_E_squo^2 * P_E_tot_1 / common_factor_1
#yCeil_DEM_new <- small_granule_eff_gain * yCeil_DEM_squo
# Q_gamma_ratio <- Q_output_DEM_squo / gamma_DEM
# common_factor <- P_output * Q_gamma_ratio
# P_inputs <- c(P_E_squo, C_process_per_kL_squo)
# QD_vec <- c(Q_E_squo, Q_E_squo * kl_per_MT_squo)
# alpha_vec <- QD_vec^2 * P_inputs / common_factor

QD_rootfn_env <- list()
# a_DEM_vec <- a_root_squo
# P_proc_vec <- kl_per_MT_squo * C_proc_per_kl_squo
# delta_P <- NULL
a_DEM_vec <- c(a_root_squo, a_root_1)
P_proc_vec <- c(kl_per_MT_squo, kl_per_MT_1) * C_proc_per_kl_squo
delta_P <- 1.04
QD_rootfn_env[["delta_P"]] <- delta_P
QD_rootfn_env[["a_DEM_vec"]] <- a_DEM_vec
QD_rootfn_env[["P_proc_vec"]] <- P_proc_vec
QD_rootfn_env[["P_output_DEM"]] <- P_output_DEM_squo
QD_rootfn_env[["C_DEM"]] <- C_DEM_squo
#P <- 2000
#QD_input_mix(P, QD_rootfn_env)
#=============================================================
P_vec <- seq(200, 5000, length.out = 50)
#=============================================================
# P <- 1800
# QS_at_P(P, mu_alpha, sig_alpha, yCeil, m_A, s_A, N)
QS_env <- list()
QS_env[["mu_alpha"]] <- mu_alpha
QS_env[["sig_alpha"]] <- sig_alpha
QS_env[["yCeil"]] <- yCeil
QS_env[["m_A"]] <- m_A
QS_env[["s_A"]] <- s_A
QS_env[["N"]] <- N
QS_env[["lq_bounds"]] <- NULL
QS_env_squo <- QS_env
list_QS_curve <- QS_curve(P_vec, QS_env)
df_QS <- as.data.frame(do.call(rbind, list_QS_curve))
colnames(df_QS) <- c("Price (Baht / MT)", "Baseline\nSupply", "Market\nParticipation")

# Q_output_DEM_squo <- Q_NR_hm1_firm(gamma_DEM, P_output_DEM_squo, yCeil_DEM_squo, C_per_Q = C_per_Q_DEM_squo)[1]
# QD_env <- list()
# QD_env[["a_DEM"]] <- a_root_squo
# QD_env[["gamma_DEM"]] <- gamma_DEM
# QD_env[["P_output_DEM"]] <- P_output_DEM_squo
# QD_env[["Q_output_DEM"]] <- Q_output_DEM_squo
# 
# QD_env_squo <- QD_env
# list_QD_curve <- QD_curve(P_vec, QD_env)
# df_QD <- as.data.frame(do.call(rbind, list_QD_curve))
# colnames(df_QD) <- c("Price (Baht / MT)", "Baseline\nDemand")
# df_plot <- df_QS
# gg <- ggplot(df_plot, aes(x = Price, y = Supply))
# gg <- gg + geom_line()
# gg
# df_plot <- df_QD
# gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = Demand))
# gg <- gg + geom_line()
# gg

# df_plot <- merge(df_QS, df_QD)
# df_plot$`Market\nParticipation` <- NULL
# df_plot <- df_plot %>% gather(Type, `Quantity (MT)`, `Baseline\nDemand`:`Baseline\nSupply`)

bag_of_colors <- randomcoloR::distinctColorPalette(k = 20)
# distinct_colors <- sample(bag_of_colors, 2)
# gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = `Quantity (MT)`, group = Type, color = Type))
# gg <- gg + geom_line(lwd = 1)
# gg <- gg + scale_color_manual(values = distinct_colors)
# gg <- gg + coord_cartesian(ylim = c(0, 2000))
# gg <- gg + theme(legend.title = element_blank(),
#                  legend.position = "bottom")
# gg <- gg + coord_cartesian(ylim = c(0, 800), xlim = c(0, 3000))
# gg <- gg + labs(title = "Status quo equilibrium")
# #gg
# gg_eq <- gg

# interval_P <- c(200, 10000)
# equilib_vec <- QSQD_Equilib(interval_P, QS_env, QD_env)
# #equilib_vec
# P_E_squo <- equilib_vec[1]
# Q_E_squo <- equilib_vec[2]
# mkt_part_squo <- equilib_vec[3]
#=============================================================
#=============================================================
#=============================================================
#=============================================================
#=============================================================
# Technology adoption analysis
#=============================================================
#=============================================================
#=============================================================
chng_yield <- -0.15
chng_yield_pct <- 100 * chng_yield
delta_yield <- 1 + chng_yield
delta_CperQ <- 1 / delta_yield
delta_h <- 1 / delta_CperQ
chng_P <- 0.07
chng_P_pct <- 100 * chng_P
delta_P <- 1 + chng_P
deltas <- delta_h * delta_P
#graph_diffNR1NR0(delta_h, delta_P, yCeil)

out_list <- get_adopt_range(delta_h, delta_P, quietly = T)
adopt_bounds <- out_list[[1]]
tech_is_pro_poor <- out_list[[2]]
zero_or_full <- out_list[[4]]
which_tech <- "baseline"
lq_bounds <- get_lq_bounds(adopt_bounds, tech_is_pro_poor, which_tech, zero_or_full)
QS_env <- QS_env_squo
QS_env[["lq_bounds"]] <- lq_bounds
list_QS_curve <- QS_curve(P_vec, QS_env)
df_QS <- as.data.frame(do.call(rbind, list_QS_curve))
colnames(df_QS) <- c("Price (Baht / MT)", "Supply (MT)", "Market\nParticipation")
df_QS_0 <- df_QS
#df_QS_0 <- df_QS %>% gather(Item, Value, Supply:`Market\nParticipation`)
df_QS_0$Tech <- "Baseline\nSupply"
QS_env_0 <- QS_env

# df_plot <- df_QS_0
# gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = Value))
# gg <- gg + geom_line()
# #gg <- gg + geom_vline(xintercept = P_1 / delta_h, color = "violet", size = 1)
# gg <- gg + facet_wrap(~Item, ncol = 1, scales = "free")
# gg


which_tech <- "new"
lq_bounds <- get_lq_bounds(adopt_bounds, tech_is_pro_poor, which_tech, zero_or_full)
QS_env <- QS_env_squo
QS_env[["lq_bounds"]] <- lq_bounds
QS_env[["mu_alpha"]] <- mu_alpha / deltas
QS_env[["sig_alpha"]] <- abs(cv_alpha * mu_alpha / deltas)
list_QS_curve <- QS_curve(P_vec, QS_env)
df_QS <- as.data.frame(do.call(rbind, list_QS_curve))
colnames(df_QS) <- c("Price (Baht / MT)", "Supply (MT)", "Market\nParticipation")
df_QS_1 <- df_QS
#df_QS_1 <- df_QS %>% gather(Item, Value, Supply:`Market\nParticipation`)
df_QS_1$Tech <- "Small Granule\nSupply"
QS_env_1 <- QS_env

# df_plot <- df_QS_1
# gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = Value))
# gg <- gg + geom_line()
# gg <- gg + facet_wrap(~Item, ncol = 1, scales = "free")
# gg

df_QS_composite <- as.data.frame(df_QS_0[, 1])
colnames(df_QS_composite)[1] <- colnames(df_QS_0)[1]
df_QS_composite$`Supply (MT)` <- df_QS_0$`Supply (MT)` + df_QS_1$`Supply (MT)`
df_QS_composite$`Market\nParticipation` <- df_QS_0$`Market\nParticipation` + df_QS_1$`Market\nParticipation`
df_QS_composite$Tech <- "Composite"
df_QS_1_0_comp <- rbind(df_QS_0, df_QS_1, df_QS_composite)

AdoptRate <- df_QS_1$`Market\nParticipation` / (df_QS_1$`Market\nParticipation` + df_QS_0$`Market\nParticipation`)
n_bins <- length(P_vec)
df_plotAR <- data.frame(xmin = P_vec[-n_bins], xmax = P_vec[-1])
df_plotAR$`Adoption\nRate` <- AdoptRate[-1]
df_plot <- df_QS_1_0_comp

#-------------
good_colors_3 <- c("#E5E3D6", "#B3DADE", "#D3E55D")
good_colors_2 <- c("#DAAC50", "#D488DE")
#distinct_background_colors <- sample(bag_of_colors, 2)
distinct_background_colors <- good_colors_2
#distinct_line_colors <- sample(bag_of_colors, 3)
distinct_line_colors <- good_colors_3
line_size <- 1.2
#-------------

gg <- ggplot()
gg <- gg + geom_rect(data = df_plotAR, aes(xmin = xmin, xmax = xmax,
                                           ymin = 0, ymax = Inf, fill = `Adoption\nRate`), alpha = 0.8)
gg <- gg + scale_fill_gradient(low = distinct_background_colors[1], high = distinct_background_colors[2])
gg <- gg + geom_line(data = df_plot, aes(x = `Price (Baht / MT)`, y = `Supply (MT)`, group = Tech, color = Tech), size = line_size)
gg <- gg + scale_color_manual(values = distinct_line_colors)
gg <- gg + labs(title = "Supply impact of small granule release")
gg <- gg + theme_bw()
gg <- gg + theme(axis.text.x = element_blank(),
                 axis.title.x = element_blank(),
                 axis.ticks.x = element_blank())
#gg
gg_supply <- gg




gg <- ggplot()
gg <- gg + geom_rect(data = df_plotAR, aes(xmin = xmin, xmax = xmax,
                                           ymin = 0, ymax = Inf, fill = `Adoption\nRate`), alpha = 0.8)
gg <- gg + scale_fill_gradient(low = distinct_background_colors[1], high = distinct_background_colors[2])
gg <- gg + geom_line(data = df_plot, aes(x = `Price (Baht / MT)`, y = `Market\nParticipation`, group = Tech, color = Tech), size = line_size)
gg <- gg + scale_color_manual(values = distinct_line_colors)
gg <- gg + theme_bw()
gg <- gg + theme(legend.position = "none")
#gg
gg_mktPart <- gg



(gg_supply / gg_mktPart) / plot_layout(heights = c(2, 1))




# gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = Supply, group = Tech, color = Tech))
# gg <- gg + geom_line(lwd = 1.1)
# gg <- gg + scale_color_manual(values = distinct_colors)
# gg <- gg + facet_wrap(~Item, ncol = 1, scales = "free")
# gg <- gg + theme(axis.title.y = element_blank())
# gg_mktPart_supply <- gg



# df_QD_0 <- df_QD
# colnames(df_QD_0)[2] <- "Quantity (MT)"
# df_QD_0$Type <- "Baseline\nDemand"
# QD_env_0 <- QD_env_squo
# QD_env_1 <- QD_env_squo
# Q_output_DEM_1 <- Q_NR_hm1_firm(gamma_DEM, P_output_DEM_squo, yCeil_DEM_new, C_per_Q = C_per_Q_DEM_squo)[1]
# QD_env_1[["a_DEM"]] <- a_root_1
# QD_env_1[["Q_output_DEM"]] <- Q_output_DEM_1
# list_QD_curve <- QD_curve(P_vec, QD_env_1)
# df_QD_1 <- as.data.frame(do.call(rbind, list_QD_curve))
# colnames(df_QD_1) <- c("Price (Baht / MT)", "Quantity (MT)")
# df_QD_1$Type <- "Small Granule\nDemand"
# df_QD_1_0 <- rbind(df_QD_0, df_QD_1)


# df_QS_0 <- subset(df_QS_0, Item != "Market\nParticipation")
# df_QS_0$Item <- NULL
# colnames(df_QS_0)[2:3] <- c("Quantity (MT)", "Type")
# df_QS_QD_0 <- rbind(df_QS_0, df_QD_0)
# df_plot <- df_QS_QD_0
# distinct_colors <- sample(bag_of_colors, 2)
# gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = `Quantity (MT)`, group = Type, color = Type))
# gg <- gg + geom_line(lwd = 1.1)
# gg <- gg + scale_color_manual(values = distinct_colors)
# gg <- gg + theme(legend.title = element_blank(),
#                  axis.title.y = element_blank(),
#                  axis.title.x = element_blank())
# gg <- gg + coord_cartesian(ylim = c(0, 1500), xlim = c(0, 5500))
# gg <- gg + labs(title = "Equilibrium after release")
# #gg 
# gg_baseline <- gg
# 
# df_QS_1 <- subset(df_QS_1, Item != "Market\nParticipation")
# df_QS_1$Item <- NULL
# colnames(df_QS_1)[2:3] <- c("Quantity (MT)", "Type")
# df_QS_QD_1 <- rbind(df_QS_1, df_QD_1)
# df_plot <- df_QS_QD_1
# distinct_colors <- sample(bag_of_colors, 2)
# gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = `Quantity (MT)`, group = Type, color = Type))
# gg <- gg + geom_line(lwd = 1.1)
# gg <- gg + scale_color_manual(values = distinct_colors)
# gg <- gg + theme(legend.title = element_blank(),
#                  axis.title.y = element_blank())
# gg <- gg + coord_cartesian(ylim = c(1, 1500), xlim = c(0, 5500))
# #gg 
# gg_new <- gg
# 
# # df_QS_composite <- df_QS_1_0 %>% group_by(`Price (Baht / MT)`) %>% summarise(`Quantity (MT)` = sum(Value))
# # df_QS_composite$Type <- "Composite Supply"
# # df_QD_composite <- df_QD_1_0 %>% group_by(`Price (Baht / MT)`) %>% summarise(`Quantity (MT)` = sum(`Quantity (MT)`))
# # df_QD_composite$Type <- "Composite Demand"
# # df_QS_QD <- rbind(df_QS_composite, df_QD_composite)
# # df_plot <- df_QS_QD
# # distinct_colors <- sample(bag_of_colors, 2)
# # gg <- ggplot(df_plot, aes(x = `Price (Baht / MT)`, y = `Quantity (MT)`, group = Type, color = Type))
# # gg <- gg + geom_line(lwd = 1.1)
# # gg <- gg + labs(title = "After release")
# # gg <- gg + scale_color_manual(values = distinct_colors)
# # gg <- gg + theme(legend.title = element_blank(),
# #                  legend.position = "bottom")
# # gg <- gg + coord_cartesian(ylim = c(0, 1500))
# # gg
# # gg_composite <- gg
# 
# gg_eq + (gg_baseline / gg_new) + plot_layout(ncol = 2, widths = c(2, 1))
# 
# interval_P <- c(500, 10000)
# equilib_vec_0 <- QSQD_Equilib(interval_P, QS_env_0, QD_env_0)
# equilib_vec_1 <- QSQD_Equilib(interval_P, QS_env_1, QD_env_1)
# # equilib_vec_0
# # equilib_vec_1
# #----
# if(length(equilib_vec_0) > 3){
#     P_E_0 <- equilib_vec_0[1]
#   P_E_0_b <- equilib_vec_0[2]
# Q_E_0 <- equilib_vec_0[3]
# Q_E_0_b <- equilib_vec_0[4]
#   mkt_part_0 <- equilib_vec_0[5]
#   mkt_part_0_b <- equilib_vec_0[6]
# }else{
#       P_E_0 <- equilib_vec_0[1]
#       Q_E_0 <- equilib_vec_0[2]
#   mkt_part_0 <- equilib_vec_0[3]
# }
# #----
# if(length(equilib_vec_1) > 3){
#       P_E_1 <- equilib_vec_1[1]
#   P_E_1_b <- equilib_vec_1[2]
# Q_E_1 <- equilib_vec_1[3]
# Q_E_1_b <- equilib_vec_1[4]
#   mkt_part_1 <- equilib_vec_1[5]
#   mkt_part_1_b <- equilib_vec_1[6]
# }else{
#         P_E_1 <- equilib_vec_1[1]
#       Q_E_1 <- equilib_vec_1[2]
#   mkt_part_1 <- equilib_vec_1[3]
# }
# #----
# Q_E_tot <- Q_E_0 + Q_E_1
# adoption_rate <- mkt_part_1 / (mkt_part_1 + mkt_part_0)
# mkt_part_tot <- mkt_part_0 + mkt_part_1
# mkt_part_diff <- mkt_part_tot - mkt_part_squo
# str_part_chng <- ifelse(mkt_part_diff < 0, "down", "up")
# str_part_but_while <- ifelse(mkt_part_diff < 0, "but", "while")
# mktPart_up_or_down <- paste(str_part_chng, mkt_part_diff)
# 
# outvec <- Q_NR_hm1_firm(gamma_DEM, P_output_DEM_squo, yCeil_DEM_new, C = C_DEM_squo, quietly = T)
# Q_ethanol_tot <- outvec[1]
# Q_ethanol_tot
# NR <- outvec[2]
# #NR
# Q_ethanol_0 <- Q_E_0 * kl_per_MT_squo
# Q_ethanol_1 <- Q_E_1 * kl_per_MT_1
# Q_ethanol_tot_check <- Q_ethanol_0 + Q_ethanol_1
# Q_ethanol_tot_check
# C <- P_E_0 * Q_E_0 + P_E_1 * Q_E_1 + C_process_per_kL_squo * (kl_per_MT_1 * Q_E_1 + kl_per_MT_squo * Q_E_0)
# C / Q_ethanol_tot
# R <- Q_ethanol_tot_check * P_output_DEM_squo
# NR_check <- R - C
# NR_check
# 
# Q_ethanol_squo / (Q_E_squo * kl_per_MT_squo)

```

Recent evidence gathered by Newby and Cu Thi [-@newby2018] indicates that root prices and quantities supplied are prone to swing by as much as 100% in the face of diverse crop and value added alternatives competing for a place in the farmers' parcels and budgets. Small granule cassava would enter the fray as yet another alternative. Careful attention to the details enumerated above is required in order to determine the conditions (the expected small granule yield loss and factory premium, in particular) under which root markets will clear at equilibria prices and quantities that are acceptable to both factories and farmers. 

In an exploratory modeling exercise based on Thai factory and farm information presented by Sriroth et al. [-@sriroth2010promise] and Tran [-@TranPersComm2018], small granule and baseline cassava supply curves were calculated assuming a small granule yield drop of `r chng_yield_pct`%, and a small granule factory premium of `r chng_P_pct`%, with respect to the baseline variety. These curves are displayed in Figure \ref{fig:supply_particip_exercise} (top panel), together with the composite root supply curve (which is just their sum). The graphic offers a glimpse of the counter-intuitive supply bahvior that can result, including regions of negative slope, when farmers are presented with an ambiguous altnernative.

In this exercise, only the supply side has been considered. The determination of equilibrium prices and quantities, of course, requires careful modeling on the demand side as well. Once equilibria can be found, one may begin to map out combinations of small granule yield loss and factory premiums that are, according to some decisionmaker's criteria, optimal. A factory may want to know, for example, the minimum premium they must offer in order to secure 100% adoption. Governments may want to know the maximum price floor they must sustain in order to offset farmer fears of pest and disease just enough to secure an optimal level of supply. Economic modeling can answer such questions, but this requires careful design and calibration, which, in turn, requires stakeholder engagement.


<!-- Based on Thai factory and farm information presented by Sriroth et al. [-@sriroth2010promise] and Tran [-@TranPersComm2018], the status quo supply and demand market equilibrium is displayed on the left side of Figure \ref{fig:mktEquilib}. The righthand panel displays the new market equilbria for the baseline and small granule varieties, assuming a `chng_yield_pct`% reduction in yield associated with the small granule variety, and a `chng_P_pct`% premium over and above the baseline root price. -->

<!-- At the status quo equilibrium, ethanol output  -->

<!-- The model then indicates that the premium offered in this scenario is sufficient to evoke an equilibrium supply response of `Q_E_1` metric tons (MT) of small granule cassava, and `Q_E_0` MT of the baseline variety. The corresponding equilibrium factory gate prices are `P_E_1` Baht/MT and `P_E_0`, respectively. The corresponding factory output is `Q_E_ethanol` kl of CE, `Qeth_up_or_down` from the status quo CE output. -->

<!-- The estimated adoption rate is `adopt_rate_pct`%, `mktPart_but_while` farm participation in the market is `mkt_part_tot_pct`%, `mktPart_up_or_down` from the status quo participation. The baseline and small granule supply and Market\nParticipation curves are given in Figure \ref{fig:mktPart_and_supply}. Note how the baseline curves bend back on themselves as the premium increases past a critical point. -->

<!-- This is consistent with the evidence recently documented by Newby and Cu Thi [-@newby2018], indicating factory gate price swings of 100% in South East Asia as farmers allocate land and resources between competing uses in response to price signals. -->

<!-- In a 2016 Thai cassava ethanol (CE) factory trial, a switch to small granule cassava chip feedstock increased Simultaneous Liquefaction, Saccharification, and Fermentation (SLSF) ethanol production by 14% over the baseline cassava chip feedstock (Tranh 2016 pers. comm.).   -->

<!-- The supply response for traditional cash crops like soybean, rice, and maize tends to come in the form of increased planted area rather than yield, because the farmers of such crops are already achieving yields near the biophysical maximum [@rao1989agricultural]. In the case of cassava, however, which is relatively new on the industrial scene, yields are still low with respect to their biophysical potential; and so the supply response is composed of adjustments both to yield (through better management, increased expenditure on inputs, etc.) and area. -->

<!--  Whereas these conventional approaches assume arbitrarily shaped  -->
<!-- supply and demand functions, DEPEMap builds up supply and demand curves from their underlying distributions of factor endowments.  -->

<!--  different from existing impact assessment models not  -->
<!-- because it makes new claims or modifications to existing theory, but because it is built up from an explicit application of the theory, in particular the microeconomic axioms of 1)  -->

\pagebreak

# Appendix

Below, the cassava supply model depicted in Figure \ref{fig:supply_particip_exercise} is derived mathematically from assumptions. 

Assumption 1: Marginal returns to expenditures on inputs are diminishing.

\begin{equation}
\frac{\partial \ln y }{\partial \ln x_i} = \alpha_i \frac{d \ln x_i}{d x_i}, \forall i \in (1,n)
\end{equation}

where $y$ is yield, $x_i$ is the $i^{th}$ input, $\alpha_i$ is the $i^{th}$ proportionality constant represetning yield responsiveness to changes in the $i^{th}$ input, and $n$ is the number of inputs. This assumption can be written in vector notation as follows:

\begin{equation}
\nabla_{\ln \mathbf{x}} \ln y = D_{\mathbf{\alpha}} \nabla_{\mathbf{x}} \ln{\mathbf{x}}
\label{eq:assump1}
\end{equation}

where $D_{\mathbf{v}}$ stands for a matrix with the vector $\mathbf{v}$ as its diagonal elements and zero elsewhere; and, to be clear,

\begin{equation}
\nabla_{\ln \mathbf{x}} \ln y = \begin{bmatrix}
\partial \ln y / \partial \ln x_1\\ 
\partial \ln y / \partial \ln x_2\\ 
\vdots\\
\partial \ln y / \partial \ln x_n
\end{bmatrix}
\end{equation}

and

\begin{equation}
\nabla_{\mathbf{x}} \ln \mathbf{x}  = \begin{bmatrix}
\partial \ln x_1 / \partial x_1\\ 
\partial \ln x_2 / \partial x_2\\ 
\vdots\\
\partial \ln x_n / \partial x_n
\end{bmatrix}
\end{equation}

The yield equation can be derived from equation \ref{eq:assump1} by dotting through by $d \ln \mathbf{x}$ and then integrating as follows:

\begin{equation}
\int \nabla_{\mathbf{x}} \ln{y} \cdot d \ln \mathbf{x} = \int D_{\mathbf{\alpha}} \nabla_{\mathbf{x}} \ln \mathbf{x} \cdot d \ln \mathbf{x}
\end{equation}

\begin{equation}

\end{equation}






\pagebreak

# References

